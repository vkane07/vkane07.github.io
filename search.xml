<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>设计模式调优之单例模式</title>
    <url>/posts/279951034.html</url>
    <content><![CDATA[<p>如何创建单一对象优化系统性能？</p>
<p>在《Design Patterns: Elements of Reusable Object-Oriented Software》一书中，有 23 种设计模式的描述，其中，单例设计模式是最常用的设计模式之一。无论是在开源框架，还是在我们的日常开发中，单例模式几乎无处不在。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>什么是单例模式？它的核心在于，单例模式可以保证一个类仅创建一个实例，并提供一个访问它的全局访问点。该模式有三个基本要点：一是这个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。结合这三点，我们来实现一个简单的单例：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//饿汉模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance=<span class="keyword">new</span> <span class="title class_">Singleton</span>();<span class="comment">//自行创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;<span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;<span class="comment">//通过该函数向整个系统提供实例</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>由于在一个系统中，一个类经常会被使用在不同的地方，通过单例模式，我们可以避免多次创建多个实例，从而节约系统资源。</p>
<h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><p>我们可以发现，以上第一种实现单例的代码中，使用了 static 修饰了成员变量 instance，所以该变量会在类初始化的过程中被收集进类构造器即 方法中。在多线程场景下，JVM 会保证只有一个线程能执行该类的 方法，其它线程将会被阻塞等待。</p>
<p>等到唯一的一次 方法执行完成，其它线程将不会再执行 方法，转而执行自己的代码。也就是说，static 修饰了成员变量 instance，在多线程的情况下能保证只实例化一次。</p>
<p>这种方式实现的单例模式，在类初始化阶段就已经在堆内存中开辟了一块内存，用于存放实例化对象，所以也称为饿汉模式。</p>
<p><strong>饿汉模式实现的单例的优点:</strong></p>
<ul>
<li>保证多线程情况下实例的唯一性</li>
<li>getInstance 直接返回唯一实例，性能非常高。</li>
</ul>
<p>饿汉模式实现的单例的缺点:</p>
<ul>
<li>在类成员变量比较多，或变量比较大的情况下，这种模式可能会在没有使用类对象的情况下，一直占用堆内存</li>
</ul>
<p><strong>ps:</strong> 试想下，如果一个第三方开源框架中的类都是基于饿汉模式实现的单例，这将会初始化所有单例类，无疑是灾难性的。</p>
<h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><p>懒汉模式就是为了避免直接加载类对象时提前创建对象的一种单例设计模式。该模式使用懒加载方式，只有当系统使用到类对象时，才会将实例加载到堆内存中。通过以下代码，我们可以简单地了解下懒加载的实现方式：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance= <span class="literal">null</span>;<span class="comment">//不实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;<span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;<span class="comment">//通过该函数向整个系统提供实例</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> == instance)&#123;<span class="comment">//当instance为null时，则实例化对象，否则直接返回对象</span></span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();<span class="comment">//实例化对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;<span class="comment">//返回已存在的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>以上代码</strong>在单线程下运行是没有问题的，但要<strong>运行在多线程下，就会出现实例化多个类对象的情况</strong>。这是怎么回事呢？</p>
<p>当线程 A 进入到 if 判断条件后，开始实例化对象，此时 instance 依然为 null；又有线程 B 进入到 if 判断条件中，之后也会通过条件判断，进入到方法里面创建一个实例对象。所以我们需要对该方法进行加锁，保证多线程情况下仅创建一个实例。这里我们<strong>使用 Synchronized 同步锁来修饰 getInstance 方法</strong>：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉模式 + synchronized同步锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance= <span class="literal">null</span>;<span class="comment">//不实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;<span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;<span class="comment">//加同步锁，通过该函数向整个系统提供实例</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> == instance)&#123;<span class="comment">//当instance为null时，则实例化对象，否则直接返回对象</span></span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();<span class="comment">//实例化对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;<span class="comment">//返回已存在的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>但我们前面讲过，同步锁会增加锁竞争，带来系统性能开销，从而导致系统性能下降，因此这种方式也会降低单例模式的性能。</p>
<p>还有，每次请求获取类对象时，都会通过 getInstance() 方法获取，除了第一次为 null，其它每次请求基本都是不为 null 的。在没有加同步锁之前，是因为 if 判断条件为 null 时，才导致创建了多个实例。基于以上两点，我们可以考虑<strong>将同步锁放在 if 条件里面</strong>，这样就可以减少同步锁资源竞争。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉模式 + synchronized同步锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance= <span class="literal">null</span>;<span class="comment">//不实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;<span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;<span class="comment">//加同步锁，通过该函数向整个系统提供实例</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> == instance)&#123;<span class="comment">//当instance为null时，则实例化对象，否则直接返回对象</span></span><br><span class="line">          <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">              instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();<span class="comment">//实例化对象</span></span><br><span class="line">          &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;<span class="comment">//返回已存在的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>看到这里，你是不是觉得这样就可以了呢？答案是<strong>依然会创建多个实例</strong>。这<strong>是因为当多个线程进入到 if 判断条件里，虽然有同步锁，但是进入到判断条件里面的线程依然会依次获取到锁创建对象，然后再释放同步锁</strong>。所以我们还需要在同步锁里面再加一个判断条件：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉模式 + synchronized同步锁 + double-check</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance= <span class="literal">null</span>;<span class="comment">//不实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;<span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;<span class="comment">//加同步锁，通过该函数向整个系统提供实例</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> == instance)&#123;<span class="comment">//第一次判断，当instance为null时，则实例化对象，否则直接返回对象</span></span><br><span class="line">          <span class="keyword">synchronized</span> (Singleton.class)&#123;<span class="comment">//同步锁</span></span><br><span class="line">             <span class="keyword">if</span>(<span class="literal">null</span> == instance)&#123;<span class="comment">//第二次判断</span></span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();<span class="comment">//实例化对象</span></span><br><span class="line">             &#125;</span><br><span class="line">          &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;<span class="comment">//返回已存在的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>以上这种方式，通常被称为 <strong>Double-Check</strong>，它可以大大提高支持多线程的懒汉模式的运行性能。那这样做是不是就能保证万无一失了呢？还会有什么问题吗？</p>
<p>其实这里又跟 Happens-Before 规则和重排序扯上关系了，这里我们先来简单了解下 Happens-Before 规则和重排序。</p>
<p>编译器为了尽可能地减少寄存器的读取、存储次数，会充分复用寄存器的存储值，比如以下代码，如果没有进行重排序优化，正常的执行顺序是步骤 1&#x2F;2&#x2F;3，而在编译期间进行了重排序优化之后，执行的步骤有可能就变成了步骤 1&#x2F;3&#x2F;2，这样就能减少一次寄存器的存取次数。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//步骤1：加载a变量的内存地址到寄存器中，加载1到寄存器中，CPU通过mov指令把1写入到寄存器指定的内存中</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;<span class="comment">//步骤2 加载b变量的内存地址到寄存器中，加载2到寄存器中，CPU通过mov指令把2写入到寄存器指定的内存中</span></span><br><span class="line">a = a + <span class="number">1</span>;<span class="comment">//步骤3 重新加载a变量的内存地址到寄存器中，加载1到寄存器中，CPU通过mov指令把1写入到寄存器指定的内存中</span></span><br></pre></td></tr></table></figure></div>

<p><strong>在 JMM 中，重排序是十分重要的一环，特别是在并发编程中</strong>。如果 JVM 可以对它们进行任意排序以提高程序性能，也可能会给并发编程带来一系列的问题。例如，我上面讲到的 Double-Check 的单例问题，假设类中有其它的属性也需要实例化，这个时候，除了要实例化单例类本身，还需要对其它属性也进行实例化：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉模式 + synchronized同步锁 + double-check</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance= <span class="literal">null</span>;<span class="comment">//不实例化</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; list = <span class="literal">null</span>;<span class="comment">//list属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line">      list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    &#125;<span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;<span class="comment">//加同步锁，通过该函数向整个系统提供实例</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> == instance)&#123;<span class="comment">//第一次判断，当instance为null时，则实例化对象，否则直接返回对象</span></span><br><span class="line">          <span class="keyword">synchronized</span> (Singleton.class)&#123;<span class="comment">//同步锁</span></span><br><span class="line">             <span class="keyword">if</span>(<span class="literal">null</span> == instance)&#123;<span class="comment">//第二次判断</span></span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();<span class="comment">//实例化对象</span></span><br><span class="line">             &#125;</span><br><span class="line">          &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;<span class="comment">//返回已存在的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在执行 instance &#x3D; new Singleton(); 代码时，正常情况下，实例过程这样的：</p>
<ul>
<li><p>给 Singleton 分配内存；</p>
</li>
<li><p>调用 Singleton 的构造函数来初始化成员变量；</p>
</li>
<li><p>将 Singleton 对象指向分配的内存空间（执行完这步 singleton 就为非 null 了）。</p>
</li>
</ul>
<p>如果虚拟机发生了重排序优化，这个时候步骤 3 可能发生在步骤 2 之前。如果初始化线程刚好完成步骤 3，而步骤 2 没有进行时，则刚好有另一个线程到了第一次判断，这个时候判断为非 null，并返回对象使用，这个时候实际没有完成其它属性的构造，因此使用这个属性就很可能会导致异常。在这里，Synchronized 只能保证可见性、原子性，无法保证执行的顺序。</p>
<p>这个时候，就体现出 Happens-Before 规则的重要性了。通过字面意思，你可能会误以为是前一个操作发生在后一个操作之前。然而真正的意思是，前一个操作的结果可以被后续的操作获取。这条规则规范了编译器对程序的重排序优化。</p>
<p>我们知道 volatile 关键字可以保证线程间变量的可见性，简单地说就是当线程 A 对变量 X 进行修改后，在线程 A 后面执行的其它线程就能看到变量 X 的变动。除此之外，volatile 在 JDK1.5 之后还有一个作用就是阻止局部重排序的发生，也就是说，volatile 变量的操作指令都不会被重排序。所以使用 volatile 修饰 instance 之后，Double-Check 懒汉单例模式就万无一失了。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉模式 + synchronized同步锁 + double-check</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance= <span class="literal">null</span>;<span class="comment">//不实例化</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; list = <span class="literal">null</span>;<span class="comment">//list属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line">      list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    &#125;<span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;<span class="comment">//加同步锁，通过该函数向整个系统提供实例</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> == instance)&#123;<span class="comment">//第一次判断，当instance为null时，则实例化对象，否则直接返回对象</span></span><br><span class="line">          <span class="keyword">synchronized</span> (Singleton.class)&#123;<span class="comment">//同步锁</span></span><br><span class="line">             <span class="keyword">if</span>(<span class="literal">null</span> == instance)&#123;<span class="comment">//第二次判断</span></span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();<span class="comment">//实例化对象</span></span><br><span class="line">             &#125;</span><br><span class="line">          &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;<span class="comment">//返回已存在的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="通过内部类实现"><a href="#通过内部类实现" class="headerlink" title="通过内部类实现"></a>通过内部类实现</h3><p>以上这种同步锁 +Double-Check 的实现方式相对来说，复杂且加了同步锁，那有没有稍微简单一点儿的可以实现线程安全的懒加载方式呢？</p>
<p>我们知道，在饿汉模式中，我们使用了 static 修饰了成员变量 instance，所以该变量会在类初始化的过程中被收集进类构造器即<code>&lt;clinit&gt;</code>方法中。在多线程场景下，JVM 会保证只有一个线程能执行该类的<code>&lt;clinit&gt;</code>方法，其它线程将会被阻塞等待。这种方式可以保证内存的可见性、顺序性以及原子性。</p>
<p>如果我们在 Singleton 类中创建一个内部类来实现成员变量的初始化，则可以避免多线程下重复创建对象的情况发生。这种方式，只有在第一次调用 getInstance() 方法时，才会加载 InnerSingleton 类，而只有在加载 InnerSingleton 类之后，才会实例化创建对象。具体实现如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉模式 内部类实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> List&lt;String&gt; list = <span class="literal">null</span>;<span class="comment">// list属性</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;<span class="comment">//构造函数</span></span><br><span class="line">    list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内部类实现</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance=<span class="keyword">new</span> <span class="title class_">Singleton</span>();<span class="comment">//自行创建实例</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> InnerSingleton.instance;<span class="comment">// 返回内部类中的静态变量</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>使用枚举来实现单例模式</strong>，具体代码如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinletonExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SinletonExample</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SinletonExample</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SinletonExample <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Sinleton.SINLETON.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> <span class="title class_">Sinleton</span>&#123;</span><br><span class="line">        SINLETON;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> SinletonExample singleton;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JVM保证这个方法只调用一次</span></span><br><span class="line">        Sinleton()&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> <span class="title class_">SinletonExample</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> SinletonExample <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单例的实现方式其实有很多，但总结起来就两种：饿汉模式和懒汉模式，我们可以根据自己的需求来做选择。</p>
<p>如果我们在程序启动后，一定会加载到类，那么用饿汉模式实现的单例简单又实用；如果我们是写一些工具类，则优先考虑使用懒汉模式，因为很多项目可能会引用到 jar 包，但未必会使用到这个工具类，<strong>懒汉模式实现的单例可以避免提前被加载到内存中，占用系统资源</strong>。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java性能调优</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Git配置</title>
    <url>/posts/279951033.html</url>
    <content><![CDATA[<h2 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h2><ul>
<li>查看git 配置的username和邮箱</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global --list</span></span><br></pre></td></tr></table></figure></div>

<p>若出现<code>git@github.com: Permission denied (publickey).</code>问题，在github 设置中配置当台主机的<code>id_rsa.pub</code>即可，目录一般在<code>C:\Users\.ssh</code>下</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>详解遗传算法GA</title>
    <url>/posts/3398872312.html</url>
    <content><![CDATA[<p>本文分享遗传算法 (GA , Genetic Algorithm) ，也称进化算法！</p>
<h2 id="遗传算法理论的由来"><a href="#遗传算法理论的由来" class="headerlink" title="遗传算法理论的由来"></a>遗传算法理论的由来</h2><p>我们先从查尔斯·达尔文的一句名言开始：</p>
<blockquote>
<p>能够生存下来的往往不是最强大的物种，也不是最聪明的物种，而是最能适应环境的物种。</p>
</blockquote>
<p>你也许在想：这句话和遗传算法有什么关系？其实遗传算法的整个概念就基于这句话。</p>
<p>让我们用一个基本例子来解释 ：</p>
<p>我们先假设一个情景，现在你是一国之王，为了让你的国家免于灾祸，你实施了一套法案：</p>
<ul>
<li>你选出所有的好人，要求其通过生育来扩大国民数量。</li>
<li>这个过程持续进行了几代。</li>
<li>你将发现，你已经有了一整群的好人。</li>
</ul>
<p>这个例子虽然不太可能，但是我用它是想帮助你理解概念。也就是说，我们改变了输入值（比如：人口），就可以获得更好的输出值（比如：更好的国家）。现在，我假定你已经对这个概念有了大致理解，认为遗传算法的含义应该和生物学有关系。那么我们就快速地看一些小概念，这样便可以将其联系起来理解。</p>
<h2 id="生物学的启发"><a href="#生物学的启发" class="headerlink" title="生物学的启发"></a>生物学的启发</h2><p>相信你还记得这句话：「细胞是所有生物的基石。」由此可知，在一个生物的任何一个细胞中，都有着相同的一套染色体。所谓染色体，就是指由 DNA 组成的聚合体。</p>
<p><img src="/../images/GA1.png" alt="GA1"></p>
<p>传统上看，这些染色体可以被由数字 0 和 1 组成的字符串表达出来。</p>
<p>C</p>
<p>一条染色体由基因组成，这些基因其实就是组成 DNA 的基本结构，DNA 上的每个基因都编码了一个独特的性状，比如，头发或者眼睛的颜色。希望你在继续阅读之前先回忆一下这里提到的生物学概念。结束了这部分，现在我们来看看所谓遗传算法实际上指的是什么？</p>
<h2 id="遗传算法定义"><a href="#遗传算法定义" class="headerlink" title="遗传算法定义"></a>遗传算法定义</h2><p>首先我们回到前面讨论的那个例子，并总结一下我们做过的事情。</p>
<ol>
<li>首先，我们设定好了国民的初始人群大小。</li>
<li>然后，我们定义了一个函数，用它来区分好人和坏人。</li>
<li>再次，我们选择出好人，并让他们繁殖自己的后代。</li>
<li>最后，这些后代们从原来的国民中替代了部分坏人，并不断重复这一过程。</li>
</ol>
<p>遗传算法实际上就是这样工作的，也就是说，它基本上尽力地在某种程度上模拟进化的过程。因此，为了形式化定义一个遗传算法，我们可以将它看作一个优化方法，它可以尝试找出某些输入，凭借这些输入我们便可以得到最佳的输出值或者是结果。遗传算法的工作方式也源自于生物学，具体流程见下图：</p>
<p><img src="/../images/GA3.png" alt="GA3"></p>
<p>那么现在我们来逐步理解一下整个流程。</p>
<h2 id="遗传算法具体步骤"><a href="#遗传算法具体步骤" class="headerlink" title="遗传算法具体步骤"></a>遗传算法具体步骤</h2><p>为了让讲解更为简便，我们先来理解一下著名的组合优化问题「背包问题」。如果你还不太懂，这里有一个我的解释版本。</p>
<p>比如，你准备要去野游 1 个月，但是你只能背一个限重 30 公斤的背包。现在你有不同的必需物品，它们每一个都有自己的「生存点数」（具体在下表中已给出）。因此，你的目标是在有限的背包重量下，最大化你的「生存点数」。</p>
<p><img src="/../images/GA4.png" alt="GA4"></p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>这里我们用遗传算法来解决这个背包问题。第一步是定义我们的总体。总体中包含了个体，每个个体都有一套自己的染色体。</p>
<p>我们知道，染色体可表达为二进制数串，在这个问题中，1 代表接下来位置的基因存在，0 意味着丢失。（这里借用染色体、基因来解决前面的背包问题，所以特定位置上的基因代表了上方背包问题表格中的物品，比如第一个位置上是 Sleeping Bag，那么此时反映在染色体的『基因』位置就是该染色体的第一个『基因』。）</p>
<p><img src="/../images/GA5.png" alt="GA5"></p>
<p>现在，我们将图中的 4 条染色体看作我们的总体初始值。</p>
<h3 id="适应度函数"><a href="#适应度函数" class="headerlink" title="适应度函数"></a>适应度函数</h3><p>接下来，让我们来计算一下前两条染色体的适应度分数。对于 A1 染色体 [100110] 而言，有：</p>
<p><img src="/../images/GA6.png" alt="GA6"></p>
<p>类似地，对于 A2 染色体 [001110] 来说，有：</p>
<p><img src="/../images/GA7.png" alt="GA7"></p>
<p>对于这个问题，我们认为，当染色体包含更多生存分数时，也就意味着它的适应性更强。</p>
<p>因此，由图可知，染色体 1 适应性强于染色体 2。</p>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>现在，我们可以开始从总体中选择适合的染色体，来让它们互相『交配』，产生自己的下一代了。这个是进行选择操作的大致想法，但是这样将会导致染色体在几代之后相互差异减小，失去了多样性。因此，我们一般会进行「轮盘赌选择法」（Roulette Wheel Selection method）。</p>
<p><img src="/../images/GA8.png" alt="GA8"></p>
<p>想象有一个轮盘，现在我们将它分割成 m 个部分，这里的 m 代表我们总体中染色体的个数。每条染色体在轮盘上占有的区域面积将根据适应度分数成比例表达出来。</p>
<p><img src="/../images/GA9.png" alt="GA9"></p>
<p>基于上图中的值，我们建立如下「轮盘」。</p>
<p><img src="/../images/GA10.png" alt="GA10"></p>
<p>现在，这个轮盘开始旋转，我们将被图中固定的指针（fixed point）指到的那片区域选为第一个亲本。然后，对于第二个亲本，我们进行同样的操作。有时候我们也会在途中标注两个固定指针，如下图：</p>
<p><img src="/../images/GA11.png" alt="GA11"></p>
<p>通过这种方法，我们可以在一轮中就获得两个亲本。我们将这种方法成为「随机普遍选择法」（Stochastic Universal Selection method）。</p>
<h3 id="交叉"><a href="#交叉" class="headerlink" title="交叉"></a>交叉</h3><p>在上一个步骤中，我们已经选择出了可以产生后代的亲本染色体。那么用生物学的话说，所谓「交叉」，其实就是指的繁殖。现在我们来对染色体 1 和 4（在上一个步骤中选出来的）进行「交叉」，见下图：</p>
<p><img src="/../images/GA12.png" alt="GA12"></p>
<p>这是交叉最基本的形式，我们称其为「单点交叉」。这里我们随机选择一个交叉点，然后，将交叉点前后的染色体部分进行染色体间的交叉对调，于是就产生了新的后代。</p>
<p>如果你设置两个交叉点，那么这种方法被成为「多点交叉」，见下图：</p>
<p><img src="/../images/GA13.png" alt="GA13"></p>
<h3 id="变异"><a href="#变异" class="headerlink" title="变异"></a>变异</h3><p>如果现在我们从生物学的角度来看这个问题，那么请问：由上述过程产生的后代是否有和其父母一样的性状呢？答案是否。在后代的生长过程中，它们体内的基因会发生一些变化，使得它们与父母不同。这个过程我们称为「变异」，它可以被定义为染色体上发生的随机变化，正是因为变异，种群中才会存在多样性。</p>
<p>下图为变异的一个简单示例：</p>
<p><img src="/../images/G14.png" alt="GA14"></p>
<p>变异完成之后，我们就得到了新为个体，进化也就完成了，整个过程如下图：</p>
<p><img src="/../images/GA15.png" alt="GA15"></p>
<p>在进行完一轮「遗传变异」之后，我们用适应度函数对这些新的后代进行验证，如果函数判定它们适应度足够，那么就会用它们从总体中替代掉那些适应度不够的染色体。这里有个问题，我们最终应该以什么标准来判断后代达到了最佳适应度水平呢？</p>
<p>一般来说，有如下几个终止条件：</p>
<ol>
<li>在进行 X 次迭代之后，总体没有什么太大改变。</li>
<li>我们事先为算法定义好了进化的次数。</li>
<li>当我们的适应度函数已经达到了预先定义的值。</li>
</ol>
<p>好了，现在我假设你已基本理解了遗传算法的要领，那么现在让我们用它在数据科学的场景中应用一番。</p>
<h2 id="遗传算法的应用"><a href="#遗传算法的应用" class="headerlink" title="遗传算法的应用"></a>遗传算法的应用</h2><h3 id="特征选取"><a href="#特征选取" class="headerlink" title="特征选取"></a>特征选取</h3><p>试想一下每当你参加一个数据科学比赛，你会用什么方法来挑选那些对你目标变量的预测来说很重要的特征呢？你经常会对模型中特征的重要性进行一番判断，然后手动设定一个阈值，选择出其重要性高于这个阈值的特征。</p>
<p>那么，有没有什么方法可以更好地处理这个问题呢？其实处理特征选取任务最先进的算法之一就是遗传算法。</p>
<p>我们前面处理背包问题的方法可以完全应用到这里。现在，我们还是先从建立「染色体」总体开始，这里的染色体依旧是二进制数串，「1」表示模型包含了该特征，「0 表示模型排除了该特征」。</p>
<p>不过，有一个不同之处，即我们的适应度函数需要改变一下。这里的适应度函数应该是这次比赛的的精度的标准。也就是说，如果染色体的预测值越精准，那么就可以说它的适应度更高。</p>
<p>现在我假设你已经对这个方法有点一概念了。下面我不会马上讲解这个问题的解决过程，而是让我们先来用 TPOT 库去实现它。</p>
<h3 id="用-TPOT-库来实现"><a href="#用-TPOT-库来实现" class="headerlink" title="用 TPOT 库来实现"></a>用 TPOT 库来实现</h3><p>这个部分相信是你在一开始读本文时心里最终想实现的那个目标。即：实现。那么首先我们来快速浏览一下 TPOT 库（Tree-based Pipeline Optimisation Technique，树形传递优化技术），该库基于 scikit-learn 库建立。下图为一个基本的传递结构</p>
<p><img src="/../images/GA16.png" alt="GA16"></p>
<p>图中的灰色区域用 TPOT 库实现了自动处理。实现该部分的自动处理需要用到遗传算法。</p>
<p>我们这里不深入讲解，而是直接应用它。为了能够使用 TPOT 库，你需要先安装一些 TPOT 建立于其上的 python 库。下面我们快速安装它们：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># installing DEAP, update_checker and tqdm </span></span><br><span class="line"></span><br><span class="line">pip install deap update_checker tqdm</span><br><span class="line"><span class="comment"># installling TPOT </span></span><br><span class="line">pip install tpot</span><br></pre></td></tr></table></figure></div>

<p>这里，我用了 Big Mart Sales（数据集地址：<a href="https://datahack.analyticsvidhya.com/contest/practice-problem-big-mart-sales-iii/%EF%BC%89%E6%95%B0%E6%8D%AE%E9%9B%86%EF%BC%8C%E4%B8%BA%E5%AE%9E%E7%8E%B0%E5%81%9A%E5%87%86%E5%A4%87%EF%BC%8C%E6%88%91%E4%BB%AC%E5%85%88%E5%BF%AB%E9%80%9F%E4%B8%8B%E8%BD%BD%E8%AE%AD%E7%BB%83%E5%92%8C%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6%EF%BC%8C%E4%BB%A5%E4%B8%8B%E6%98%AF">https://datahack.analyticsvidhya.com/contest/practice-problem-big-mart-sales-iii/）数据集，为实现做准备，我们先快速下载训练和测试文件，以下是</a> python 代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># import basic libraries</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line">%matplotlib inline </span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing </span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error </span><br><span class="line"><span class="comment">## preprocessing </span></span><br><span class="line"><span class="comment">### mean imputations </span></span><br><span class="line"></span><br><span class="line">train[<span class="string">&#x27;Item_Weight&#x27;</span>].fillna((train[<span class="string">&#x27;Item_Weight&#x27;</span>].mean()), inplace=<span class="literal">True</span>)</span><br><span class="line">test[<span class="string">&#x27;Item_Weight&#x27;</span>].fillna((test[<span class="string">&#x27;Item_Weight&#x27;</span>].mean()), inplace=<span class="literal">True</span>) </span><br><span class="line"><span class="comment">### reducing fat content to only two categories </span></span><br><span class="line"></span><br><span class="line">train[<span class="string">&#x27;Item_Fat_Content&#x27;</span>] = train[<span class="string">&#x27;Item_Fat_Content&#x27;</span>].replace([<span class="string">&#x27;low fat&#x27;</span>,<span class="string">&#x27;LF&#x27;</span>], [<span class="string">&#x27;Low Fat&#x27;</span>,<span class="string">&#x27;Low Fat&#x27;</span>]) </span><br><span class="line">train[<span class="string">&#x27;Item_Fat_Content&#x27;</span>] = train[<span class="string">&#x27;Item_Fat_Content&#x27;</span>].replace([<span class="string">&#x27;reg&#x27;</span>], [<span class="string">&#x27;Regular&#x27;</span>]) </span><br><span class="line">test[<span class="string">&#x27;Item_Fat_Content&#x27;</span>] = test[<span class="string">&#x27;Item_Fat_Content&#x27;</span>].replace([<span class="string">&#x27;low fat&#x27;</span>,<span class="string">&#x27;LF&#x27;</span>], [<span class="string">&#x27;Low Fat&#x27;</span>,<span class="string">&#x27;Low Fat&#x27;</span>]) </span><br><span class="line">test[<span class="string">&#x27;Item_Fat_Content&#x27;</span>] = test[<span class="string">&#x27;Item_Fat_Content&#x27;</span>].replace([<span class="string">&#x27;reg&#x27;</span>], [<span class="string">&#x27;Regular&#x27;</span>]) </span><br><span class="line">train[<span class="string">&#x27;Outlet_Establishment_Year&#x27;</span>] = <span class="number">2013</span> - train[<span class="string">&#x27;Outlet_Establishment_Year&#x27;</span>] </span><br><span class="line">test[<span class="string">&#x27;Outlet_Establishment_Year&#x27;</span>] = <span class="number">2013</span> - test[<span class="string">&#x27;Outlet_Establishment_Year&#x27;</span>] </span><br><span class="line"></span><br><span class="line">train[<span class="string">&#x27;Outlet_Size&#x27;</span>].fillna(<span class="string">&#x27;Small&#x27;</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">test[<span class="string">&#x27;Outlet_Size&#x27;</span>].fillna(<span class="string">&#x27;Small&#x27;</span>,inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">train[<span class="string">&#x27;Item_Visibility&#x27;</span>] = np.sqrt(train[<span class="string">&#x27;Item_Visibility&#x27;</span>])</span><br><span class="line">test[<span class="string">&#x27;Item_Visibility&#x27;</span>] = np.sqrt(test[<span class="string">&#x27;Item_Visibility&#x27;</span>])</span><br><span class="line"></span><br><span class="line">col = [<span class="string">&#x27;Outlet_Size&#x27;</span>,<span class="string">&#x27;Outlet_Location_Type&#x27;</span>,<span class="string">&#x27;Outlet_Type&#x27;</span>,<span class="string">&#x27;Item_Fat_Content&#x27;</span>]</span><br><span class="line">test[<span class="string">&#x27;Item_Outlet_Sales&#x27;</span>] = 0combi = train.append(test)<span class="keyword">for</span> i <span class="keyword">in</span> col:</span><br><span class="line"> combi[i] = number.fit_transform(combi[i].astype(<span class="string">&#x27;str&#x27;</span>))</span><br><span class="line"> combi[i] = combi[i].astype(<span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">train = combi[:train.shape[<span class="number">0</span>]]</span><br><span class="line">test = combi[train.shape[<span class="number">0</span>]:]</span><br><span class="line">test.drop(<span class="string">&#x27;Item_Outlet_Sales&#x27;</span>,axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">## removing id variables </span></span><br><span class="line"></span><br><span class="line">tpot_train = train.drop([<span class="string">&#x27;Outlet_Identifier&#x27;</span>,<span class="string">&#x27;Item_Type&#x27;</span>,<span class="string">&#x27;Item_Identifier&#x27;</span>],axis=<span class="number">1</span>)</span><br><span class="line">tpot_test = test.drop([<span class="string">&#x27;Outlet_Identifier&#x27;</span>,<span class="string">&#x27;Item_Type&#x27;</span>,<span class="string">&#x27;Item_Identifier&#x27;</span>],axis=<span class="number">1</span>)</span><br><span class="line">target = tpot_train[<span class="string">&#x27;Item_Outlet_Sales&#x27;</span>]</span><br><span class="line">tpot_train.drop(<span class="string">&#x27;Item_Outlet_Sales&#x27;</span>,axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># finally building model using tpot library</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tpot <span class="keyword">import</span> TPOTRegressor</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(tpot_train, target,</span><br><span class="line"> train_size=<span class="number">0.75</span>, test_size=<span class="number">0.25</span>)</span><br><span class="line"></span><br><span class="line">tpot = TPOTRegressor(generations=<span class="number">5</span>, population_size=<span class="number">50</span>, verbosity=<span class="number">2</span>)</span><br><span class="line">tpot.fit(X_train, y_train)</span><br><span class="line"><span class="built_in">print</span>(tpot.score(X_test, y_test))</span><br><span class="line">tpot.export(<span class="string">&#x27;tpot_boston_pipeline.py&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p><img src="/../images/GA17.png" alt="GA17">一旦这些代码运行完成，tpot_exported_pipeline.py 里就将会放入用于路径优化的 python 代码。我们可以发现，ExtraTreeRegressor 可以最好地解决这个问题。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PYTHON"><figure class="iseeu highlight /python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## predicting using tpot optimised pipeline</span></span><br><span class="line"></span><br><span class="line">tpot_pred = tpot.predict(tpot_test)</span><br><span class="line">sub1 = pd.DataFrame(data=tpot_pred)</span><br><span class="line"><span class="comment">#sub1.index = np.arange(0, len(test)+1)</span></span><br><span class="line"></span><br><span class="line">sub1 = sub1.rename(columns = &#123;<span class="string">&#x27;0&#x27;</span>:<span class="string">&#x27;Item_Outlet_Sales&#x27;</span>&#125;)</span><br><span class="line">sub1[<span class="string">&#x27;Item_Identifier&#x27;</span>] = test[<span class="string">&#x27;Item_Identifier&#x27;</span>]</span><br><span class="line">sub1[<span class="string">&#x27;Outlet_Identifier&#x27;</span>] = test[<span class="string">&#x27;Outlet_Identifier&#x27;</span>]</span><br><span class="line">sub1.columns = [<span class="string">&#x27;Item_Outlet_Sales&#x27;</span>,<span class="string">&#x27;Item_Identifier&#x27;</span>,<span class="string">&#x27;Outlet_Identifier&#x27;</span>]</span><br><span class="line">sub1 = sub1[[<span class="string">&#x27;Item_Identifier&#x27;</span>,<span class="string">&#x27;Outlet_Identifier&#x27;</span>,<span class="string">&#x27;Item_Outlet_Sales&#x27;</span>]]</span><br><span class="line">sub1.to_csv(<span class="string">&#x27;tpot.csv&#x27;</span>,index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></div>

<p>如果你提交了这个 csv，那么你会发现我一开始保证的那些还没有完全实现。那是不是我在骗你们呢？当然不是。实际上，TPOT 库有一个简单的规则。如果你不运行 TPOT 太久，那么它就不会为你的问题找出最可能传递方式。</p>
<p>所以，你得增加进化的代数，拿杯咖啡出去走一遭，其它的交给 TPOT 就行。此外，你也可以用这个库来处理分类问题。进一步内容可以参考这个文档：<a href="http://rhiever.github.io/tpot/%E3%80%82%E9%99%A4%E4%BA%86%E6%AF%94%E8%B5%9B%EF%BC%8C%E5%9C%A8%E7%94%9F%E6%B4%BB%E4%B8%AD%E6%88%91%E4%BB%AC%E4%B9%9F%E6%9C%89%E5%BE%88%E5%A4%9A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%88%B0%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E3%80%82">http://rhiever.github.io/tpot/。除了比赛，在生活中我们也有很多应用场景可以用到遗传算法。</a></p>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>遗传算法在真实世界中有很多应用。这里我列了部分有趣的场景，但是由于篇幅限制，我不会逐一详细介绍。</p>
<h3 id="工程设计"><a href="#工程设计" class="headerlink" title="工程设计"></a>工程设计</h3><p>工程设计非常依赖计算机建模以及模拟，这样才能让设计周期过程即快又经济。遗传算法在这里可以进行优化并给出一个很好的结果。</p>
<p>相关资源：</p>
<ul>
<li>论文：Engineering design using genetic algorithms</li>
<li>地址：<a href="http://lib.dr.iastate.edu/cgi/viewcontent.cgi?article=16942&context=rtd">http://lib.dr.iastate.edu/cgi/viewcontent.cgi?article=16942&amp;context=rtd</a></li>
</ul>
<h3 id="交通与船运路线（Travelling-Salesman-Problem，巡回售货员问题）"><a href="#交通与船运路线（Travelling-Salesman-Problem，巡回售货员问题）" class="headerlink" title="交通与船运路线（Travelling Salesman Problem，巡回售货员问题）"></a>交通与船运路线（Travelling Salesman Problem，巡回售货员问题）</h3><p>这是一个非常著名的问题，它已被很多贸易公司用来让运输更省时、经济。解决这个问题也要用到遗传算法。</p>
<p><img src="/../images/GA18.png" alt="GA18"></p>
<p><img src="/../images/GA19.png" alt="GA19"></p>
<h3 id="机器人"><a href="#机器人" class="headerlink" title="机器人"></a>机器人</h3><p>遗传算法在机器人领域中的应用非常广泛。实际上，目前人们正在用遗传算法来创造可以像人类一样行动的自主学习机器人，其执行的任务可以是做饭、洗衣服等等。</p>
<p>相关资源：</p>
<ul>
<li>论文：Genetic Algorithms for Auto-tuning Mobile Robot Motion Control</li>
<li>地址：<a href="https://pdfs.semanticscholar.org/7c8c/faa78795bcba8e72cd56f8b8e3b95c0df20c.pdf">https://pdfs.semanticscholar.org/7c8c/faa78795bcba8e72cd56f8b8e3b95c0df20c.pdf</a></li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>希望通过本文介绍，你现在已经对遗传算法有了足够的理解，而且也会用 TPOT 库来实现它了。但是如果你不亲身实践，本文的知识也是非常有限的。</p>
<p>所以，请各位读者朋友一定要在无论是数据科学比赛或是生活中尝试自己去实现它。 </p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>大厂面试智力题</title>
    <url>/posts/2823024016.html</url>
    <content><![CDATA[<p>大厂相关智力题。</p>
<h2 id="微软面试题：红帽子与黑帽子"><a href="#微软面试题：红帽子与黑帽子" class="headerlink" title="微软面试题：红帽子与黑帽子"></a>微软面试题：红帽子与黑帽子</h2><p><strong>故事起源：</strong></p>
<p>一群人开舞会，每人都戴着一顶帽子。帽子只有红和黑两种，其中黑的至少有一顶。每个人能看到其它人的帽子颜色，但看不到自己的。</p>
<p>大家先一起做一个游戏，规则如下：<br>所有人先看别人头上戴的是什么帽子，然后关灯，如果有人认为自己戴的黑帽子，就打自己一个耳光。</p>
<p><strong>游戏开始：</strong></p>
<p>第一次关灯，没有声音。</p>
<p><img src="/../images/%E7%BA%A2%E5%B8%BD%E5%92%8C%E9%BB%91%E5%B8%BD1.png" alt="红帽和黑帽1">  </p>
<p>于是打开灯再看一遍，第二次关灯，依然鸦雀无声。<br>一直到第三次关灯，才有声音响起。</p>
<p><img src="/../images/%E7%BA%A2%E5%B8%BD%E5%92%8C%E9%BB%91%E5%B8%BD2.png" alt="红帽和黑帽2"></p>
<p>问：有多少人戴着黑帽子？</p>
<p><img src="/../images/%E7%BA%A2%E5%B8%BD%E5%92%8C%E9%BB%91%E5%B8%BD3.png" alt="红帽和黑帽3"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>假设有5个红帽子，和5个黑帽子。</p>
<p><img src="/../images/%E7%BA%A2%E5%B8%BD%E5%92%8C%E9%BB%91%E5%B8%BD4.png" alt="红帽和黑帽4"></p>
<p>对于红帽子的人，他看到的是有4个红帽子，和5个黑帽子。</p>
<p><img src="/../images/%E7%BA%A2%E5%B8%BD%E5%92%8C%E9%BB%91%E5%B8%BD5.png" alt="红帽和黑帽5"></p>
<p>对于黑帽子的人，他看到的是有5个红帽子，和4个黑帽子。</p>
<p><img src="/../images/%E7%BA%A2%E5%B8%BD%E5%92%8C%E9%BB%91%E5%B8%BD6.png" alt="红帽和黑帽6"></p>
<p>那么第一次关灯，对于任何一个人，只能得到上面的信息，他是无法判断自己的帽子颜色的，所以肯定啥也不发生。</p>
<p><img src="/../images/%E7%BA%A2%E5%B8%BD%E5%92%8C%E9%BB%91%E5%B8%BD7.png" alt="红帽和黑帽7"></p>
<h3 id="寻找突破口"><a href="#寻找突破口" class="headerlink" title="寻找突破口"></a>寻找突破口</h3><p>题目是问戴黑帽子的有几个人，跟具体人数相关。但我们再回到题目描述，并没有给总共多少人，也没有说红帽子有多少人，只有一个跟数字相关的条件，就是戴黑帽子的至少有一人，这就是突破口。</p>
<p>所以这类的问题都可以从题目的信息量上面寻找突破口。<br>没有说红帽子有多少人，说明解题的思路肯定跟红帽子没什么关系，有多少都无所谓，那就从黑帽子开始思考。</p>
<h3 id="小规模简单场景"><a href="#小规模简单场景" class="headerlink" title="小规模简单场景"></a>小规模简单场景</h3><h4 id="假设只有1个黑帽子"><a href="#假设只有1个黑帽子" class="headerlink" title="假设只有1个黑帽子"></a>假设只有1个黑帽子</h4><p>对于每一个红帽子，他看到的场景是这样的。第一次关灯他们都无法确定自己帽子的颜色。</p>
<p><img src="/../images/%E7%BA%A2%E5%B8%BD%E5%92%8C%E9%BB%91%E5%B8%BD8.png" alt="红帽和黑帽8"></p>
<p>对于唯一的一个黑帽子，他看到的场景是这样的。因为至少有一个黑帽子，他没有看到，所以推出自己一定是黑帽子，第一次关灯声音响起。</p>
<p><img src="/../images/%E7%BA%A2%E5%B8%BD%E5%92%8C%E9%BB%91%E5%B8%BD9.png" alt="红帽和黑帽9"></p>
<h4 id="假设有2个黑帽子"><a href="#假设有2个黑帽子" class="headerlink" title="假设有2个黑帽子"></a>假设有2个黑帽子</h4><p>对于每一个红帽子，他看到的场景是这样的。第一次关灯他们是无法判断的。</p>
<p><img src="/../images/%E7%BA%A2%E5%B8%BD%E5%92%8C%E9%BB%91%E5%B8%BD10.png" alt="红帽和黑帽10"></p>
<p>对于2个黑帽子，他看到的场景是这样的。</p>
<p><img src="/../images/%E7%BA%A2%E5%B8%BD%E5%92%8C%E9%BB%91%E5%B8%BD11.png" alt="红帽和黑帽11"></p>
<p>第一次关灯，他们都在等对方打耳光，所以什么也不会发生。</p>
<p><img src="/../images/%E7%BA%A2%E5%B8%BD%E5%92%8C%E9%BB%91%E5%B8%BD12.png" alt="红帽和黑帽12"></p>
<p>因为第一次没有声音，这时他俩都知道，第一次对方在等自己打耳光。所以这时他们都可以判断自己是黑帽子，第二次关灯声音响起。</p>
<p><img src="/../images/%E7%BA%A2%E5%B8%BD%E5%92%8C%E9%BB%91%E5%B8%BD13.png" alt="红帽和黑帽13"></p>
<h4 id="假设有3个黑帽子"><a href="#假设有3个黑帽子" class="headerlink" title="假设有3个黑帽子"></a>假设有3个黑帽子</h4><p>对于红帽子的人来说，一定比黑帽子的人后得到信息，所以不考虑。</p>
<p><img src="/../images/%E7%BA%A2%E5%B8%BD%E5%92%8C%E9%BB%91%E5%B8%BD14.png" alt="红帽和黑帽14"></p>
<p>对于其中的每一个黑帽子，他们认为2次之后对方可以发现，结果两次之后因为都在等，不会有声音，那第三次都可以判断自己是黑帽子了。</p>
<p><img src="/../images/%E7%BA%A2%E5%B8%BD%E5%92%8C%E9%BB%91%E5%B8%BD15.png" alt="红帽和黑帽15"></p>
<h4 id="假设有N个黑帽子"><a href="#假设有N个黑帽子" class="headerlink" title="假设有N个黑帽子"></a>假设有N个黑帽子</h4><p>根据上面分析，可以推论第N次声音响起。所以题目第3次有声音，也就意味着有3个黑帽子。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于所有的红帽子，他们的地位是相同的，也就是视角永远一样，对黑帽子也同样成立，所以如果有信息就会是同时得到，而不是一些人先发现。那这个问题就分红黑两类来考虑就行了。这也是属于博弈论相关的问题，可以先考虑小数据的简单场景。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>智力题</tag>
      </tags>
  </entry>
  <entry>
    <title>内存上升问题排查</title>
    <url>/posts/3928563964.html</url>
    <content><![CDATA[<p>平时我们都会遇到内存溢出，或是内存使用率过高的问题。碰到内存持续上升的情况，我们很难从业务日志中查看到具体的问题，那么面对多个进程以及大量业务线程，我们该如何精准地找到背后的原因呢？</p>
<h2 id="常用的监控和诊断内存工具"><a href="#常用的监控和诊断内存工具" class="headerlink" title="常用的监控和诊断内存工具"></a>常用的监控和诊断内存工具</h2><p>工欲善其事，必先利其器。平时排查内存性能瓶颈时，我们往往需要用到一些 Linux 命令行或者 JDK 工具来辅助我们监测系统或者虚拟机内存的使用情况，下面我就来介绍几种好用且常用的工具。</p>
<h3 id="Linux-命令行工具之-top-命令"><a href="#Linux-命令行工具之-top-命令" class="headerlink" title="Linux 命令行工具之 top 命令"></a>Linux 命令行工具之 top 命令</h3><p>top 命令是Linux 下最常用的命令之一，它可以实时显示正在执行进程的 CPU 使用率、内存使用率以及系统负载等信息。其中上半部分显示的是系统的统计信息，下半部分显示的是进程的使用率统计信息。</p>
<p><img src="/../images/top%E5%91%BD%E4%BB%A41.png" alt="top命令1"></p>
<p>除了简单的 top 之外，我们还可以通过 top -Hp pid 查看具体线程使用系统资源情况：</p>
<p><img src="/../images/top%E5%91%BD%E4%BB%A42.png" alt="top命令2"></p>
<h3 id="Linux-命令行工具之-vmstat-命令"><a href="#Linux-命令行工具之-vmstat-命令" class="headerlink" title="Linux 命令行工具之 vmstat 命令"></a>Linux 命令行工具之 vmstat 命令</h3><p>vmstat 是一款指定采样周期和次数的功能性监测工具，我们可以看到，它不仅可以统计内存的使用情况，还可以观测到 CPU 的使用率、swap 的使用情况。但 vmstat 一般很少用来查看内存的使用情况，而是经常被用来观察进程的上下文切换。</p>
<p><img src="/../images/vmstat%E5%91%BD%E4%BB%A4.png" alt="vmstat命令"></p>
<ul>
<li>r：等待运行的进程数；</li>
<li>b：处于非中断睡眠状态的进程数；</li>
<li>swpd：虚拟内存使用情况；</li>
<li>free：空闲的内存；</li>
<li>buff：用来作为缓冲的内存数；</li>
<li>si：从磁盘交换到内存的交换页数量；</li>
<li>so：从内存交换到磁盘的交换页数量；</li>
<li>bi：发送到块设备的块数；</li>
<li>bo：从块设备接收到的块数；</li>
<li>in：每秒中断数；</li>
<li>cs：每秒上下文切换次数；</li>
<li>us：用户 CPU 使用时间；</li>
<li>sy：内核 CPU 系统使用时间；</li>
<li>id：空闲时间；</li>
<li>wa：等待 I&#x2F;O 时间；</li>
<li>st：运行虚拟机窃取的时间</li>
</ul>
<h3 id="Linux-命令行工具之-pidstat-命令"><a href="#Linux-命令行工具之-pidstat-命令" class="headerlink" title="Linux 命令行工具之 pidstat 命令"></a>Linux 命令行工具之 pidstat 命令</h3><p>pidstat 是 Sysstat 中的一个组件，也是一款功能强大的性能监测工具，可以通过命令：<code>yum install sysstat </code>安装该监控组件。之前的<code>top</code>和 <code>vmstat</code> 两个命令都是<strong>监测进程的内存、CPU 以及 I&#x2F;O</strong> 使用情况，而<code> pidstat</code> 命令则是深入到线程级别。</p>
<p>通过 <code>pidstat -help</code> 命令，我们可以查看到有以下几个常用的参数来监测线程的性能：</p>
<p><img src="/../images/pidstat%E5%91%BD%E4%BB%A4.png" alt="pidstat命令"></p>
<p>常用参数：</p>
<ul>
<li>-u：默认的参数，显示各个进程的 cpu 使用情况；</li>
<li>-r：显示各个进程的内存使用情况；</li>
<li>-d：显示各个进程的 I&#x2F;O 使用情况；</li>
<li>-w：显示每个进程的上下文切换情况；</li>
<li>-p：指定进程号；</li>
<li>-t：显示进程中线程的统计信息。</li>
</ul>
<p>可以通过相关命令（例如 ps 或 jps）查询到相关进程 ID，再运行以下命令来监测该进程的内存使用情况：</p>
<p><img src="/../images/pidstat%E5%91%BD%E4%BB%A42.png" alt="pidstat命令2"></p>
<p>其中 pidstat 的参数 -p 用于指定进程 ID，-r 表示监控内存的使用情况，1 表示每秒的意思，3 则表示采样次数。其中显示的几个关键指标的含义是：</p>
<ul>
<li>Minflt&#x2F;s：任务每秒发生的次要错误，不需要从磁盘中加载页；</li>
<li>Majflt&#x2F;s：任务每秒发生的主要错误，需要从磁盘中加载页；</li>
<li>VSZ：虚拟地址大小，虚拟内存使用 KB；</li>
<li>RSS：常驻集合大小，非交换区内存使用 KB。</li>
</ul>
<p>若需要继续查看该进程下的线程内存使用率，则在后面添加 -t 指令即可：</p>
<p><img src="/../images/pidstat%E5%91%BD%E4%BB%A43.png" alt="pidstat命令3"></p>
<p>Java 是基于 JVM 上运行的，大部分内存都是在 JVM 的用户内存中创建的，所以除了通过以上 Linux 命令来监控整个服务器内存的使用情况之外，我们更需要知道 JVM 中的内存使用情况。JDK 中就自带了很多命令工具可以监测到 JVM 的内存分配以及使用情况。</p>
<h2 id="JDK-工具相关命令"><a href="#JDK-工具相关命令" class="headerlink" title="JDK 工具相关命令"></a>JDK 工具相关命令</h2><h3 id="JDK-工具之-jstat-命令"><a href="#JDK-工具之-jstat-命令" class="headerlink" title="JDK 工具之 jstat 命令"></a>JDK 工具之 jstat 命令</h3><p>jstat 可以监测 Java 应用程序的实时运行情况，包括堆内存信息以及垃圾回收信息。可以运行 <code>jstat -help </code>查看一些关键参数信息：</p>
<p><img src="/../images/jstat%E5%91%BD%E4%BB%A41.png" alt="jstat命令1"></p>
<p>再通过 jstat -option 查看 jstat 有哪些操作：</p>
<p><img src="/../images/jstat%E5%91%BD%E4%BB%A42.png" alt="jstat命令2"></p>
<ul>
<li>-class：显示 ClassLoad 的相关信息；</li>
<li>-compiler：显示 JIT 编译的相关信息；</li>
<li>-gc：显示和 gc 相关的堆信息；</li>
<li>-gccapacity：显示各个代的容量以及使用情况；</li>
<li>-gcmetacapacity：显示 Metaspace 的大小；</li>
<li>-gcnew：显示新生代信息；</li>
<li>-gcnewcapacity：显示新生代大小和使用情况；</li>
<li>-gcold：显示老年代和永久代的信息；</li>
<li>-gcoldcapacity ：显示老年代的大小；</li>
<li>-gcutil：显示垃圾收集信息；</li>
<li>-gccause：显示垃圾回收的相关信息（通 -gcutil），同时显示最后一次或当前正在发生的垃圾回收的诱因；</li>
<li>-printcompilation：输出 JIT 编译的方法信息。</li>
</ul>
<p>它的功能比较多，在这里我例举一个常用功能，如何使用 jstat 查看堆内存的使用情况。我们可以用 jstat -gc pid 查看：</p>
<p><img src="/../images/jstat%E5%91%BD%E4%BB%A43.png" alt="jstat命令3"></p>
<ul>
<li>S0C：年轻代中 To Survivor 的容量（单位 KB）；</li>
<li>S1C：年轻代中 From Survivor 的容量（单位 KB）；</li>
<li>S0U：年轻代中 To Survivor 目前已使用空间（单位 KB）；</li>
<li>S1U：年轻代中 From Survivor 目前已使用空间（单位 KB）；</li>
<li>EC：年轻代中 Eden 的容量（单位 KB）；</li>
<li>EU：年轻代中 Eden 目前已使用空间（单位 KB）；</li>
<li>OC：Old 代的容量（单位 KB）；</li>
<li>OU：Old 代目前已使用空间（单位 KB）；</li>
<li>MC：Metaspace 的容量（单位 KB）；</li>
<li>MU：Metaspace 目前已使用空间（单位 KB）；</li>
<li>YGC：从应用程序启动到采样时年轻代中 gc 次数；</li>
<li>YGCT：从应用程序启动到采样时年轻代中 gc 所用时间 (s)；</li>
<li>FGC：从应用程序启动到采样时 old 代（全 gc）gc 次数；</li>
<li>FGCT：从应用程序启动到采样时 old 代（全 gc）gc 所用时间 (s)；</li>
<li>GCT：从应用程序启动到采样时 gc 用的总时间 (s)。</li>
</ul>
<h3 id="JDK-工具之-jstack-命令"><a href="#JDK-工具之-jstack-命令" class="headerlink" title="JDK 工具之 jstack 命令"></a>JDK 工具之 jstack 命令</h3><p>这个工具是一种线<strong>程堆栈分析工具</strong>，最常用的功能就是使用 <code>jstack pid</code> 命令查看线程的堆栈信息，通常会结合 <code>top -Hp pid</code> 或 <code>pidstat -p pid -t</code> 一起查看具体线程的状态，也经常用来排查一些死锁的异常。</p>
<p><img src="/../images/jstack%E5%91%BD%E4%BB%A4.png" alt="jstack命令"></p>
<p>每个线程堆栈的信息中，都可以查看到线程 ID、线程的状态（wait、sleep、running 等状态）以及是否持有锁等。</p>
<h3 id="JDK-工具之-jmap-命令"><a href="#JDK-工具之-jmap-命令" class="headerlink" title="JDK 工具之 jmap 命令"></a>JDK 工具之 jmap 命令</h3><p><code>jmap</code> 可以查看<strong>堆内存初始化配置信息</strong>以及堆内存的使用情况，还可以使用<code> jmap</code> <strong>输出堆内存中的对象信息</strong>，包括产生了哪些对象，对象数量多少等。我们可以用 <code>jmap</code> 来查看堆内存初始化配置信息以及堆内存的使用情况：</p>
<p><img src="/../images/jmap%E5%91%BD%E4%BB%A41.png" alt="jmap命令1"></p>
<p>我们可以使用<code>jmap -histo[:live] pid</code> 查看堆内存中的对象数目、大小统计直方图，如果带上 live 则只统计活对象：</p>
<p><img src="/../images/jmap%E5%91%BD%E4%BB%A42.png" alt="jmap命令2"></p>
<p>可以通过<code> jmap</code> 命令把堆内存的使用情况 dump 到文件中：</p>
<p><img src="/../images/jmap%E5%91%BD%E4%BB%A43.png" alt="jmap命令3"></p>
<p>可以将文件下载下来，使用 MAT 工具打开文件进行分析：</p>
<p><img src="/../images/MAT1.png" alt="MAT1"></p>
<p>下文用一个实战案例来综合使用下刚刚介绍的几种工具，具体操作一下如何<strong>分析一个内存泄漏问题</strong>。</p>
<h2 id="实战演练"><a href="#实战演练" class="headerlink" title="实战演练"></a>实战演练</h2><p>我们平时遇到的内存溢出问题一般分为两种：</p>
<ul>
<li>一种是由于大峰值下没有限流，瞬间创建大量对象而导致的内存溢出；</li>
<li>另一种则是由于内存泄漏而导致的内存溢出。</li>
</ul>
<p>使用限流，一般就可以解决第一种内存溢出问题，但其实很多时候，内存溢出往往是内存泄漏导致的，这种问题就是程序的 BUG，我们需要及时找到问题代码。<br>下文<strong>模拟了一个内存泄漏导致的内存溢出案例，我们来实践一下</strong>。</p>
<p>我们知道，<strong>ThreadLocal 的作用是提供线程的私有变量</strong>，这种变量可以在一个线程的整个生命周期中传递，可以减少一个线程在多个函数或类中创建公共变量来传递信息，避免了复杂度。但在使用时，如果 ThreadLocal 使用不恰当，就可能导致内存泄漏。</p>
<p>这个案例的场景就是 ThreadLocal，下面模拟对每个线程设置一个本地变量。运行以下代码，系统一会儿就发送了内存溢出异常：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/test0&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test0</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    ThreadLocal&lt;Byte[]&gt; localVariable = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Byte[]&gt;();</span><br><span class="line">    localVariable.set(<span class="keyword">new</span> <span class="title class_">Byte</span>[<span class="number">4096</span>*<span class="number">1024</span>]);<span class="comment">// 为线程添加变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在启动应用程序之前，我们可以通过 <code>HeapDumpOnOutOfMemoryError</code> 和 <code>HeapDumpPath </code>这两个参数开启堆内存异常日志，通过以下命令启动应用程序：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">java -jar -Xms1000m -Xmx4000m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof  -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:/tmp/heapTest.log heapTest-<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT.jar</span><br></pre></td></tr></table></figure></div>

<p>首先，请求 test0 链接 10000 次，这个时候我们请求 test0 的接口报异常了。</p>
<p><img src="/../images/%E9%97%AE%E9%A2%98%E6%97%A5%E5%BF%97.png" alt="问题日志"></p>
<p>通过日志，我们很好分辨这是一个内存溢出异常。首先通过 Linux 系统命令查看进程在整个系统中内存的使用率是多少，最简单就是 top 命令了。</p>
<p><img src="/../images/top%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A51.png" alt="top问题排查1"></p>
<p>从 top 命令查看进程的内存使用情况，可以发现在机器只有 8G 内存且只分配了 4G 内存给 Java 进程的情况下，Java 进程内存使用率已经达到了 55%，再通过 <code>top -Hp pid</code> 查看具体线程占用系统资源情况。</p>
<p><img src="/../images/top%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A52.png" alt="top问题排查2"></p>
<p>再通过<code>jstack pid</code>查看具体线程的堆栈信息，可以发现该线程一直处于 TIMED_WAITING 状态，此时 CPU 使用率和负载并没有出现异常，我们可以排除死锁或 I&#x2F;O 阻塞的异常问题了。</p>
<p><img src="/../images/jstack%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5.png" alt="jstack问题排查"></p>
<p>再通过 jmap 查看堆内存的使用情况，可以发现，老年代的使用率几乎快占满了，而且内存一直得不到释放：</p>
<p><img src="/../images/jmap%E6%8E%92%E6%9F%A51.png" alt="jmap排查1"></p>
<p>通过以上堆内存的情况，基本可以判断系统发生了内存泄漏。下面我们就需要找到具体是什么对象一直无法回收，什么原因导致了内存泄漏。</p>
<p>需要查看具体的堆内存对象，看看是哪个对象占用了堆内存，可以通过 jmap 查看存活对象的数量：</p>
<p><img src="/../images/jmap%E6%8E%92%E6%9F%A52.png" alt="jmap排查2"></p>
<p>Byte 对象占用内存明显异常，说明代码中 Byte 对象存在内存泄漏，我们在启动时，已经设置了 dump 文件，通过 MAT 打开 dump 的内存日志文件，我们可以发现 MAT 已经提示了 byte 内存异常：</p>
<p><img src="/../images/MAT2.png" alt="MAT2"></p>
<p>再点击进入到 Histogram 页面，可以查看到对象数量排序，可以看到 Byte[]数组排在了第一位，选中对象后右击选择 <code>with incomming reference </code>功能，可以查看到具体哪个对象引用了这个对象。</p>
<p><img src="/../images/MAT3.png" alt="MAT3"></p>
<p>在这里就可以很明显地查看到是 ThreadLocal 这块的代码出现了问题。</p>
<blockquote>
<p>threadlocal用完必须释放</p>
</blockquote>
<p><img src="/../images/MAT4.png" alt="MAT4"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在一些比较简单的业务场景下，排查系统性能问题相对来说简单，且容易找到具体原因。但在一些复杂的业务场景下，或是一些开源框架下的源码问题，相对来说就很难排查了，有时候通过工具只能猜测到可能是某些地方出现了问题，而实际排查则要结合源码做具体分析。可以说没有捷径，排查线上的性能问题本身就不是一件很简单的事情，除了将今天介绍的这些工具融会贯通，还需要我们不断地去累积经验，真正做到性能调优。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>问题排查</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM调优二</title>
    <url>/posts/3237053245.html</url>
    <content><![CDATA[<p>本文深入JVM即时编译器JIT，优化Java编译。</p>
<p>说到编译，一定会想到 <strong>.java 文件被编译成 .class 文件的过程</strong>，这个编译我们一般称为<strong>前端编译</strong>。</p>
<p>Java 的编译和运行过程非常复杂，除了前端编译，还有<strong>运行时编译</strong>。</p>
<p>由于<strong>机器无法直接运行 Java 生成的字节码</strong>，所以在运行时，<strong>JIT 或解释器会将字节码转换成机器码</strong>，这个过程就叫<strong>运行时编译</strong>。</p>
<p>类文件在运行时被进一步编译，它们可以变成高度优化的机器代码，由于 C&#x2F;C++ 编译器的所有优化都是在编译期间完成的，运行期间的性能监控仅作为基础的优化措施则无法进行，例如，调用频率预测、分支频率预测、裁剪未被选择的分支等，而 Java 在运行时的再次编译，就可以进行基础的优化措施。因此，<strong>JIT 编译器可以说是 JVM 中运行时编译最重要的部分之一</strong>。</p>
<p>然而许多 Java 开发人员对 JIT 编译器的了解并不多，不深挖其工作原理，也不深究如何检测应用程序的即时编译情况，线上发生问题后很难做到从容应对。下面我们就来学习运行时编译如何实现对 Java 代码的优化。</p>
<h2 id="类编译加载执行过程"><a href="#类编译加载执行过程" class="headerlink" title="类编译加载执行过程"></a>类编译加载执行过程</h2><p><img src="/../images/%E7%B1%BB%E7%BC%96%E8%AF%91%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="类编译加载过程"></p>
<h3 id="类编译"><a href="#类编译" class="headerlink" title="类编译"></a>类编译</h3><p>在编写好代码之后，需要将 .java 文件编译成 .class 文件，才能在虚拟机上正常运行代码。文件的编译通常是由 JDK 中自带的 Javac 工具完成，<strong>一个简单的 .java 文件，可以通过 javac 命令来生成 .class 文件</strong>。</p>
<p>下面我们通过 javap反编译来看看一个 class 文件结构中主要包含了哪些信息：</p>
<p><img src="/../images/%E5%8F%8D%E7%BC%96%E8%AF%91.png" alt="反编译"></p>
<p>看似一个简单的命令执行，前期编译的过程其实是非常复杂的，包括词法分析、填充符号表、注解处理、语义分析以及生成 class 文件，这个过程不用过多关注。只要从上图中知道，<strong>编译后的字节码文件主要包括常量池和方法表集合这两部分</strong>就可以了。</p>
<p><strong>常量池主要记录的是类文件中出现的字面量以及符号引用</strong>。字面常量包括字符串常量（例如 String str&#x3D;“abc”，其中”abc”就是常量），声明为 final 的属性以及一些基本类型（例如，范围在 -127-128 之间的整型）的属性。符号引用包括类和接口的全限定名、类引用、方法引用以及成员变量引用（例如 String str&#x3D;“abc”，其中 str 就是成员变量引用）等。</p>
<p>方法表集合中主要包含一些方法的字节码、方法访问权限（public、protect、prviate 等）、方法名索引（与常量池中的方法引用对应）、描述符索引、JVM 执行指令以及属性集合等。</p>
<h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p>当一个类被创建实例或者被其它对象引用时，虚拟机在没有加载过该类的情况下，会通过类加载器将字节码文件加载到内存中。</p>
<p>不同的实现类由不同的类加载器加载，JDK 中的本地方法类一般由根加载器（Bootstrp loader）加载进来，JDK 中内部实现的扩展类一般由扩展加载器（ExtClassLoader ）实现加载，而程序中的类文件则由系统加载器（AppClassLoader ）实现加载。</p>
<p><strong>在类加载后，class 类文件中的常量池信息以及其它数据会被保存到 JVM 内存的方法区中</strong>。</p>
<h3 id="类连接"><a href="#类连接" class="headerlink" title="类连接"></a>类连接</h3><p>类在加载进来之后，会进行连接、初始化，最后才会被使用。在<strong>连接过程</strong>中，又包括<strong>验证、准备和解析</strong>三个部分。</p>
<p><strong>验证：</strong>验证类符合 Java 规范和 JVM 规范，在保证符合规范的前提下，避免危害虚拟机安全。</p>
<p><strong>准备：</strong>为类的静态变量分配内存，初始化为系统的初始值。对于 final static 修饰的变量，直接赋值为用户的定义值。例如，private <strong>final</strong> static int value&#x3D;123，会在<strong>准备阶段分配内存，并初始化值为 123</strong>，而如果是 private static int value&#x3D;123，这个阶段 value 的值仍然为 0。</p>
<p><strong>解析</strong>：将符号引用转为直接引用的过程。我们知道，在编译时，Java 类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。类结构文件的常量池中存储了符号引用，包括类和接口的全限定名、类引用、方法引用以及成员变量引用等。如果要使用这些类和方法，就需要把它们<strong>转化为 JVM 可以直接获取的内存地址或指针，即直接引用</strong>。</p>
<h3 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h3><p>类初始化阶段是类加载过程的最后阶段，在这个阶段中，JVM 首先将执行构造器 <code>&lt;clinit&gt;</code>方法，编译器会在将 .java 文件编译成 .class 文件时，收集所有类初始化代码，包括静态变量赋值语句、静态代码块、静态方法，收集在一起成为 <code>&lt;clinit&gt;</code>() 方法。</p>
<p>初始化类的静态变量和静态代码块为用户自定义的值，初始化的顺序和 Java 源码从上到下的顺序一致。例如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> i=<span class="number">1</span>；</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">  i=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span>&#123;</span><br><span class="line">  System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>此时运行结果为：0</p>
<p>再来看看以下代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">  i=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> i=<span class="number">1</span>；</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span>&#123;</span><br><span class="line">  System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此时运行结果为：1</p>
<p>子类初始化时会首先调用父类的 <code>&lt;clinit&gt;</code> () 方法，再执行子类的 <code>&lt;clinit&gt;</code> () 方法，运行以下代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String parentStr= <span class="string">&quot;parent static string&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;parent static fields&quot;</span>);</span><br><span class="line">    System.out.println(parentStr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;parent instance initialization&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String subStr= <span class="string">&quot;sub static string&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;sub static fields&quot;</span>);</span><br><span class="line">    System.out.println(subStr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Sub</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;sub instance initialization&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;sub main&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">parent <span class="keyword">static</span> fields</span><br><span class="line">parent <span class="keyword">static</span> string</span><br><span class="line">sub <span class="keyword">static</span> fields</span><br><span class="line">sub <span class="keyword">static</span> string</span><br><span class="line">sub main</span><br><span class="line">parent instance initialization</span><br><span class="line">sub instance initialization</span><br></pre></td></tr></table></figure></div>

<p>JVM 会保证 <code>&lt;clinit&gt;</code> () 方法的线程安全，保证同一时间只有一个线程执行。</p>
<p>JVM 在初始化执行代码时，如果实例化一个新对象，会调用  <code>&lt;clinit&gt;</code>方法对实例变量进行初始化，并执行对应的构造方法内的代码。</p>
<h3 id="即时编译"><a href="#即时编译" class="headerlink" title="即时编译"></a>即时编译</h3><p>初始化完成后，<strong>类在调用执行过程中，执行引擎会把字节码转为机器码，然后在操作系统中才能执行</strong>。</p>
<p>在字节码转换为机器码的过程中，虚拟机中还存在着一道编译，那就是即时编译。</p>
<p>最初，虚拟机中的字节码是由解释器（ Interpreter ）完成编译的，当虚拟机发现某个方法或代码块的运行特别频繁的时候，就会把这些代码认定为“热点代码”。</p>
<p>为了提高热点代码的执行效率，在运行时，即时编译器（JIT）会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，然后<strong>保存到内存</strong>中。</p>
<h3 id="编译优化技术"><a href="#编译优化技术" class="headerlink" title="编译优化技术"></a>编译优化技术</h3><p>JIT 编译运用了一些经典的编译优化技术来实现代码的优化，即通过一些例行检查优化，可以智能地编译出运行时的最优性能代码。主要来学习以下两种优化手段：</p>
<ol>
<li><strong>方法内联</strong></li>
</ol>
<p>调用一个方法通常要经历压栈和出栈。调用方法是将程序执行顺序转移到存储该方法的内存地址，将方法的内容执行完后，再返回到执行该方法前的位置。</p>
<p>这种执行操作要求在执行前保护现场并记忆执行的地址，执行后要恢复现场，并按原来保存的地址继续执行。 因此，方法调用会产生一定的时间和空间方面的开销。</p>
<p>那么对于那些方法体代码不是很大，又频繁调用的方法来说，这个时间和空间的消耗会很大。<strong>方法内联的优化行为就是把目标方法的代码复制到发起调用的方法之中，避免发生真实的方法调用</strong>。</p>
<p>例如以下方法：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">add1</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> x2, <span class="type">int</span> x3, <span class="type">int</span> x4)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> add2(x1, x2) + add2(x3, x4);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">add2</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> x2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x1 + x2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最终会被优化为：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">add1</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> x2, <span class="type">int</span> x3, <span class="type">int</span> x4)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x1 + x2+ x3 + x4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>JVM 会自动识别热点方法，并对它们使用方法内联进行优化。</p>
<p>可以通过<code>-XX:CompileThreshold</code>来设置热点方法的阈值。但要强调一点，热点方法不一定会被 JVM 做内联优化，如果这个方法体太大了，JVM 将不执行内联操作。而方法体的大小阈值，我们也可以通过参数设置来优化：</p>
<ul>
<li>经常执行的方法，默认情况下，方法体大小小于 325 字节的都会进行内联，我以通过 <code>-XX:MaxFreqInlineSize=N</code>来设置大小值；</li>
<li>不是经常执行的方法，默认情况下，方法大小小于 35 字节才会进行内联，也可以通过<code> -XX:MaxInlineSize=N</code> 来重置大小值。</li>
</ul>
<p>之后就可以通过配置 JVM 参数来查看到方法被内联的情况：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-XX:+PrintCompilation <span class="comment">//在控制台打印编译过程信息</span></span><br><span class="line">-XX:+UnlockDiagnosticVMOptions <span class="comment">//解锁对JVM进行诊断的选项参数。默认是关闭的，开启后支持一些特定参数对JVM进行诊断</span></span><br><span class="line">-XX:+PrintInlining <span class="comment">//将内联方法打印出来</span></span><br></pre></td></tr></table></figure></div>

<p>当设置 VM 参数：<code>-XX:+PrintCompilation -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining </code>之后，运行以下代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000000</span>; i++) &#123;<span class="comment">//方法调用计数器的默认阈值在C1模式下是1500次，在C2模式在是10000次，我们循环遍历超过需要阈值</span></span><br><span class="line">      add1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>热点方法的优化可以有效提高系统性能，一般可以通过以下几种方式来提高方法内联：</p>
<ul>
<li>通过设置 JVM 参数来减小热点阈值或增加方法体阈值，以便更多的方法可以进行内联，但这种方法意味着需要占用更多地内存；</li>
<li>在编程中，避免在一个方法中写大量代码，习惯使用小方法体；尽量使用 final、private、static 关键字修饰方法，编码方法因为继承，会需要额外的类型检查。</li>
</ul>
<ol start="2">
<li><strong>逃逸分析</strong></li>
</ol>
<p>逃逸分析（Escape Analysis）是判断一个对象是否被外部方法引用或外部线程访问的分析技术，编译器会根据逃逸分析的结果对代码进行优化。</p>
<h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><p>在 Java 中默认创建一个对象是在堆中分配内存的，而当堆内存中的对象不再使用时，则需要通过垃圾回收机制回收，这个过程相对分配在栈中的对象的创建和销毁来说，更消耗时间和性能。这个时候，<strong>逃逸分析如果发现一个对象只在方法中使用，就会将对象分配在栈上</strong>。</p>
<p>以下是通过循环获取学生年龄的案例，方法中创建一个学生对象，我们现在通过案例来看看打开逃逸分析和关闭逃逸分析后，堆内存对象创建的数量对比。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">200000</span> ; i++) &#123;</span><br><span class="line">      getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">Student</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>,<span class="number">18</span>,<span class="number">30</span>);   </span><br><span class="line">    <span class="keyword">return</span> person.getAge();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后，分别设置 VM 参数：<code>Xmx1000m -Xms1000m -XX:-DoEscapeAnalysis -XX:+PrintGC</code> 以及 -<code>Xmx1000m -Xms1000m -XX:+DoEscapeAnalysis -XX:+PrintGC</code>，通过 VisualVM 工具，查看堆中创建的对象数量。</p>
<p>然而，运行结果却没有达到想要的优化效果，也许你怀疑是 JDK 版本的问题，然而分别在 1.6~1.8 版本都测试过了，效果还是一样的：</p>
<p>（<code>-server -Xmx1000m -Xms1000m -XX:-DoEscapeAnalysis -XX:+PrintGC</code>）</p>
<p><img src="/../images/%E5%A0%86%E6%96%87%E4%BB%B6(%E6%9C%AA%E5%BC%80%E5%90%AF%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90).png" alt="堆文件(未开启逃逸分析)"></p>
<p>（<code>-server -Xmx1000m -Xms1000m -XX:+DoEscapeAnalysis -XX:+PrintGC</code>）</p>
<p><img src="/../images/%E5%A0%86%E6%96%87%E4%BB%B6(%E5%BC%80%E5%90%AF%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90).png" alt="堆文件(开启逃逸分析)"></p>
<p>这其实是因为 HotSpot 虚拟机目前的实现导致栈上分配实现比较复杂，可以说，在 HotSpot 中暂时没有实现这项优化。随着即时编译器的发展与逃逸分析技术的逐渐成熟，相信不久的将来 HotSpot 也会实现这项优化功能。</p>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>在非线程安全的情况下，尽量不要使用线程安全容器，比如 StringBuffer。由于 StringBuffer 中的 append 方法被 Synchronized 关键字修饰，会使用到锁，从而导致性能下降。</p>
<p>但实际上，在以下代码测试中，StringBuffer 和 StringBuilder 的性能基本没什么区别。这是因为在局部方法中创建的对象只能被当前线程访问，无法被其它线程访问，这个变量的读写肯定不会有竞争，这个时候 JIT 编译会对这个对象的方法锁进行锁消除。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getString</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        sb.append(s1);</span><br><span class="line">        sb.append(s2);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h4><p>逃逸分析证明一个对象不会被外部访问，如果这个对象可以被拆分的话，当程序真正执行的时候可能不创建这个对象，而直接创建它的成员变量来代替。将对象拆分后，可以分配对象的成员变量在栈或寄存器上，原本的对象就无需分配内存空间了。这种编译优化就叫做标量替换。</p>
<p>用以下代码验证：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">       id = <span class="number">1</span>;</span><br><span class="line">       count = <span class="number">99</span>;</span><br><span class="line">       ...<span class="comment">//to do something</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<p>我们可以通过设置 JVM 参数来开关逃逸分析，还可以单独开关同步消除和标量替换，在 JDK1.8 中 JVM 是默认开启这些操作的。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-XX:+DoEscapeAnalysis开启逃逸分析（jdk1<span class="number">.8</span>默认开启，其它版本未测试）</span><br><span class="line">-XX:-DoEscapeAnalysis 关闭逃逸分析</span><br><span class="line"></span><br><span class="line">-XX:+EliminateLocks开启锁消除（jdk1<span class="number">.8</span>默认开启，其它版本未测试）</span><br><span class="line">-XX:-EliminateLocks 关闭锁消除</span><br><span class="line"></span><br><span class="line">-XX:+EliminateAllocations开启标量替换（jdk1<span class="number">.8</span>默认开启，其它版本未测试）</span><br><span class="line">-XX:-EliminateAllocations 关闭就可以了</span><br></pre></td></tr></table></figure></div>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要了解了 JKD1.8 以及之前的类的编译和加载过程，<strong>Java 源程序是通过 Javac 编译器编译成 .class 文件</strong>，其中文件中包含的代码格式我们称之为 <strong>Java 字节码（bytecode）</strong>。</p>
<p>这种代码格式无法直接运行，但可以被不同平台 JVM 中的 Interpreter 解释执行。由于 Interpreter 的效率低下，JVM 中的 JIT 会在运行时有选择性地将运行次数较多的方法编译成二进制代码，直接运行在底层硬件上。</p>
<p>在 Java8 之前，HotSpot 集成了两个 JIT，用 C1 和 C2 来完成 JVM 中的即时编译。虽然 JIT 优化了代码，但收集监控信息会消耗运行时的性能，且编译过程会占用程序的运行时间。</p>
<p>到了 Java9，AOT 编译器被引入。和 JIT 不同，AOT 是在程序运行前进行的静态编译，这样就可以避免运行时的编译消耗和内存消耗，且 .class 文件通过 AOT 编译器是可以编译成 .so 的二进制文件的。</p>
<p>到了 Java10，一个新的 JIT 编译器 Graal 被引入。Graal 是一个以 Java 为主要编程语言、面向 Java bytecode 的编译器。与用 C++ 实现的 C1 和 C2 相比，它的模块化更加明显，也更容易维护。Graal 既可以作为动态编译器，在运行时编译热点方法；也可以作为静态编译器，实现 AOT 编译。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>Java性能调优</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode算法</title>
    <url>/posts/2823024016.html</url>
    <content><![CDATA[<p>leetcode算法练习。</p>
<p><a href="https://leetcode.cn/problems/connecting-cities-with-minimum-cost">1135最低成本联通所有城市</a></p>
<p><strong>最小生成树</strong> 图的生成树是一棵含有其所有的顶点的无环联通子图，一幅加权图的最小生成树（ MST ） 是它的一颗权值（树中所有边的权值之和）最小的生成树。</p>
<p><strong>并查集</strong> 并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。常常在使用中以森林来表示。</p>
<p><strong>方法一：Kruskal 算法</strong></p>
<p>思路</p>
<p>根据题意，我们可以把 n 座城市看成 n 个顶点，连接两个城市的成本 cost 就是对应的权重，需要返回连接所有城市的最小成本。很显然，这是一个标准的最小生成树，首先我们介绍第一种经典算法： Kruskal 算法。</p>
<p>既然我们需要求最小成本，那么可以肯定的是这个图没有环（如果有环的话无论如何都可以删掉一条边使得成本更小）。该算法就是基于这个特性： 按照边的权重顺序（从小到大）处理所有的边，将边加入到最小生成树中，加入的边不会与已经加入的边构成环，直到树中含有 n - 1 条边为止。这些边会由一片森林变成一个树，这个树就是图的最小生成树</p>
<p><img src="/../images/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%95%B0.gif" alt="最小生成树"></p>
<p>算法</p>
<ol>
<li>将所有的边按照权重从小到大排序。</li>
<li>取一条权重最小的边。</li>
<li>使用并查集（union-find）数据结构来判断加入这条边后是否会形成环。若不会构成环，则将这条边加入最小生成树中。</li>
<li>检查所有的结点是否已经全部联通，这一点可以通过目前已经加入的边的数量来判断。若全部联通，则结束算法；否则返回步骤 2.</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumCost</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] connections)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] id = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将所有边按照权重从小到大排序</span></span><br><span class="line">        Arrays.sort(connections,(a, b)-&gt;(a[<span class="number">2</span>] != b[<span class="number">2</span>] ? a[<span class="number">2</span>]-b[<span class="number">2</span>] : a[<span class="number">0</span>] - b[<span class="number">0</span>]));</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>, cost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] c : connections) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (find(c[<span class="number">0</span>] - <span class="number">1</span>, id) == find(c[<span class="number">1</span>] - <span class="number">1</span>, id)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            union(c[<span class="number">0</span>] - <span class="number">1</span>, c[<span class="number">1</span>] - <span class="number">1</span>, id);</span><br><span class="line">            count++;</span><br><span class="line">            cost += c[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count != n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cost;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">union</span> <span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[] id)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> find(i, id);</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> find(j, id);</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        id[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span>[] id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == id[x]) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> find(id[x], id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img src="/../images/1135%E6%96%B9%E6%A1%881.png" alt="1135方案1"></p>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：O(elog⁡e+e∗n)，其中 e 为边的数量，n 为城市的数量。排序的时间复杂度为 O(elog⁡e)，我们需要遍历 e条边。对于每条边，查找两个端点的根结点最多需要经过 2n个结点。所以时间复杂度最坏为 O(e∗n)。</p>
</li>
<li><p>空间复杂度：O(n)，需要大小为 n 的并查集结构存储点的关系，其中 n 为城市的个数。</p>
</li>
</ul>
<p><strong>方法二：Kruskal 算法 + 加权 Union 算法</strong><br><strong>思路</strong></p>
<p>方法一我们检查环的过程中，最坏的情况下每次需要遍历所有的边，形成一个永远只有左子节点的树。为了避免形成这样的结构，我们可以记录每一颗树的大小并且总是将较小的树连接到较大的树上，这个算法就叫<strong>加权 Union 算法</strong>。该算法需要添加一个数组记录树中的节点数，并且在联通的时候比较节点个数，将较小的树连接到较大的树上。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumCost</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] connections)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] id = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] sz = <span class="keyword">new</span> <span class="title class_">int</span>[n]; <span class="comment">// 记录树的大小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将所有边按照权重从小到大排序</span></span><br><span class="line">        Arrays.sort(connections,(a, b)-&gt;(a[<span class="number">2</span>] != b[<span class="number">2</span>] ? a[<span class="number">2</span>]-b[<span class="number">2</span>] : a[<span class="number">0</span>] - b[<span class="number">0</span>]));</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>, cost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] c : connections) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (find(c[<span class="number">0</span>] - <span class="number">1</span>, id) == find(c[<span class="number">1</span>] - <span class="number">1</span>, id)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            union2(c[<span class="number">0</span>] - <span class="number">1</span>, c[<span class="number">1</span>] - <span class="number">1</span>, sz, id);</span><br><span class="line">            count++;</span><br><span class="line">            cost += c[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count != n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cost;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将较小的树连接到较大的树上</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">union2</span> <span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[] sz, <span class="type">int</span>[] id)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> find(i, id);</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> find(j, id);</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sz[x] &lt; sz[y]) &#123;</span><br><span class="line">            id[x] = y;</span><br><span class="line">            sz[y] += sz[x];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            id[y] = x;</span><br><span class="line">            sz[x] += sz[y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span>[] id)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == id[x]) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> find(id[x], id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img src="/../images/1135%E6%96%B9%E6%A1%882.png" alt="1135方案2"></p>
<p>复杂度分析**</p>
<ul>
<li><p>时间复杂度：O(e(log⁡e+log⁡n))，使用加权 Union 算法后，find 操作的时间复杂度为 O(log⁡n)。另外此时的时间复杂度还受排序操作制约，排序操作复杂度为 O(elog⁡e)，综合起来时间复杂度为 O(e(log⁡e+log⁡n))</p>
</li>
<li><p>空间复杂度：O(n)，需要大小为 n 的并查集结构存储点的关系，其中 n 为城市的个数。</p>
</li>
</ul>
<p><strong>方法三：Kruskal 算法 + 加权 Union 算法 + 路径压缩</strong><br><strong>思路</strong></p>
<p>考虑在方法一和方法二中我们使用的 find 函数，可以发现，一些路径是被重复寻找了的。</p>
<p>举个例子，假设在并查集中有四个结点，其中 <code>1</code> 的父亲是 <code>2</code>，<code>2</code> 的父亲是 <code>3</code>，<code>3 </code>的父亲是<code> 4</code>。那么我们在以后每次寻找 <code>1</code> 所在的集合时，都需要经过 <code>1-2-3 </code>这条路径；查找 <code>2 </code>所在的集合时，都需要经过 <code>2-3-4</code> 这条路径。可以想到，在一个大型图中，查找根结点的路径中会存在大量与此类似的重复查询。</p>
<p>而事实上，我们通过一个简单的操作来避免这样的重复查询：我们可以在 find 函数结束的时候，将路径上所有的结点，修改为根结点的直接子结点。这样，我们下次查询时，就可以直接找到刚才找到的根结点，不需要再查询一次相同的路径了。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumCost</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] connections)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] id = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] sz = <span class="keyword">new</span> <span class="title class_">int</span>[n]; <span class="comment">// 记录树的大小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将所有边按照权重从小到大排序</span></span><br><span class="line">        Arrays.sort(connections,(a, b)-&gt;(a[<span class="number">2</span>] != b[<span class="number">2</span>] ? a[<span class="number">2</span>]-b[<span class="number">2</span>] : a[<span class="number">0</span>] - b[<span class="number">0</span>]));</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>, cost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] c : connections) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (find(c[<span class="number">0</span>] - <span class="number">1</span>, id) == find(c[<span class="number">1</span>] - <span class="number">1</span>, id)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            union(c[<span class="number">0</span>] - <span class="number">1</span>, c[<span class="number">1</span>] - <span class="number">1</span>, sz, id);</span><br><span class="line">            count++;</span><br><span class="line">            cost += c[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count != n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cost;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将较小的树连接到较大的树上</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">union</span> <span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[] sz, <span class="type">int</span>[] id)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> find(i, id);</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> find(j, id);</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sz[x] &lt; sz[y]) &#123;</span><br><span class="line">            id[x] = y;</span><br><span class="line">            sz[y] += sz[x];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            id[y] = x;</span><br><span class="line">            sz[x] += sz[y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span>[] id)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (x != id[x]) &#123;</span><br><span class="line">            id[x] = id[id[x]];</span><br><span class="line">            x = id[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> id[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img src="/../images/1135%E6%96%B9%E6%A1%883.png" alt="1135方案3"></p>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：O(e∗(log⁡e+α(n)))，其中 e 为边的数量，n为城市的数量。经过优化后，find 操作的时间复杂度为 O(α(n)) ，其中 α为反阿克曼函数，其增长极其缓慢，也就是说其单次操作的平均运行时间可以认为是一个很小的常数。具体的证明过于复杂，了解结论即可。此时算法的总体时间复杂度仍然受排序操作制约，为 O(elog⁡e)，综合可得时间复杂度为 O(e∗(log⁡e+α(n)))。</p>
</li>
<li><p>空间复杂度：O(n)，需要大小为 n 的并查集结构存储点的关系，其中 n 为城市的个数。</p>
</li>
</ul>
<p><strong>方法四：Prim 算法</strong><br><strong>思路</strong></p>
<p>Kruskal 算法的核心思想是每次把权重最小的边加入到树中，Prim 算法则是依据顶点来生成的，它的每一步都会为一颗生长中的树添加一条边，一开始这棵树只有一个顶点，然后会添加 <code>n - 1 </code>条边，每次都是将下一条连接树中的顶点与不在树中的顶点且权重最小的边加入到树中。</p>
<p><strong>算法</strong></p>
<ol>
<li>根据 connections 记录每个顶点到其他顶点的权重，记为 edges 。</li>
<li>使用 visited 记录所有被访问过的点。</li>
<li>使用堆来根据权重比较所有的边。</li>
<li>将任意一个点记为已访问，并将其所有连接的边放入堆中。</li>
<li>从堆中拿出权重最小的边。</li>
<li>如果已经访问过，直接丢弃。</li>
<li>如果未访问过，标记为已访问，并且将其所有连接的边放入堆中，检查是否有 n 个点。<br>重复操作 5。</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">            <span class="type">int</span> from;</span><br><span class="line">            <span class="type">int</span> to;</span><br><span class="line">            <span class="type">int</span> weight;</span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(<span class="type">int</span> f, <span class="type">int</span> t, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">                from = f;</span><br><span class="line">                to = t;</span><br><span class="line">                weight = w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumCost</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] connections)</span> &#123;</span><br><span class="line">            Map&lt;Integer, List&lt;Edge&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] arr : connections) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> arr[<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> arr[<span class="number">2</span>];</span><br><span class="line">                <span class="comment">// 无向图转换成双向图</span></span><br><span class="line">                <span class="type">Edge</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Edge</span>(from, to, weight);</span><br><span class="line">                <span class="type">Edge</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Edge</span>(to, from, weight);</span><br><span class="line">                <span class="keyword">if</span> (graph.get(from) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    List&lt;Edge&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    list1.add(e1);</span><br><span class="line">                    graph.put(from, list1);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    graph.get(from).add(e1);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (graph.get(to) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    List&lt;Edge&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    list1.add(e2);</span><br><span class="line">                    graph.put(to, list1);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    graph.get(to).add(e2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 优先级队列 核心</span></span><br><span class="line">            Queue&lt;Edge&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((Edge a, Edge b) -&gt; (a.weight - b.weight));</span><br><span class="line">            Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 随机选一个点加进去，就选第一个点</span></span><br><span class="line">            <span class="keyword">for</span> (Edge edge : graph.get(connections[<span class="number">0</span>][<span class="number">0</span>])) &#123;</span><br><span class="line">                queue.offer(edge);</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(connections[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 边解锁点，点解锁边</span></span><br><span class="line">                <span class="type">Edge</span> <span class="variable">edge</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge.from;</span><br><span class="line">                <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> edge.to;</span><br><span class="line">                <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> edge.weight;</span><br><span class="line">                <span class="keyword">if</span> (!set.contains(to)) &#123;</span><br><span class="line">                    set.add(to);</span><br><span class="line">                    ans += weight;</span><br><span class="line">                    <span class="keyword">for</span> (Edge e : graph.get(to)) &#123;</span><br><span class="line">                        queue.offer(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// set的大小和n不一致就返回-1</span></span><br><span class="line">            <span class="keyword">if</span> (set.size() == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p><img src="/../images/1135%E6%96%B9%E6%A1%884.png" alt="1135方案4"></p>
<p><a href="https://leetcode-cn.com/problems/convert-1d-array-into-2d-array">2022. 将一维数组转变成二维数组</a></p>
<p>三种方法</p>
<p>遍历赋值</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] construct2DArray(<span class="type">int</span>[] original, <span class="type">int</span> m, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> original.length;</span><br><span class="line">        <span class="keyword">if</span>(len != m * n) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            ans[i / n][i % n] = original[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>Arrays.copyOfRange</code></p>
<ul>
<li>original：第一个参数为要拷贝的数组对象</li>
<li>from：第二个参数为拷贝的开始位置（包含）</li>
<li>to：第三个参数为拷贝的结束位置（不包含）</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[][] construct2DArray(int[] original, int m, int n) &#123;</span><br><span class="line">        int len = original.length;</span><br><span class="line">        if(len != m * n) return new int[0][0];</span><br><span class="line">        int[][] ans = new int[m][];</span><br><span class="line">        for(int i = 0;i &lt; m;i++)&#123;</span><br><span class="line">            ans[i] = Arrays.copyOfRange(original,i * n,(i + 1) * n);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><code>System.arraycopy</code></p>
<ul>
<li>第一个参数默认是src 来源数组 类型为数组</li>
<li>第二个参数默认是srcPos 从来源数组开始复制的位置 类型为整行（其实就是下标）</li>
<li>第三个参数默认是dest 目标数组 类型为数组</li>
<li>第四个参数默认是destPos 目标数组起始下标</li>
<li>第五个参数默认是length 复制的长度</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] construct2DArray(<span class="type">int</span>[] original, <span class="type">int</span> m, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> original.length;</span><br><span class="line">        <span class="keyword">if</span>(len != m * n) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">            System.arraycopy(original,i * n,ans[i],<span class="number">0</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="https://leetcode-cn.com/problems/day-of-the-week">1185. 一周中的第几天</a></p>
<p>method1:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dayOfTheWeek</span><span class="params">(<span class="type">int</span> day, <span class="type">int</span> month, <span class="type">int</span> year)</span> &#123;</span><br><span class="line">        String[] week =&#123;<span class="string">&quot;Sunday&quot;</span>, <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// 1970的最后一天是星期四</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> day + <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1971</span>; i &lt; year; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; i % <span class="number">100</span> !=<span class="number">0</span>) || (i % <span class="number">400</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">                ans += <span class="number">366</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ans += <span class="number">365</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] day4month = &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; month - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            ans += day4month[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (((year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> !=<span class="number">0</span>) || (year % <span class="number">400</span> == <span class="number">0</span>)) &amp;&amp; month &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> week[ans % <span class="number">7</span>];</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img src="/../images/1185%E6%96%B9%E6%A1%881.png" alt="1185方案1"></p>
<p>method2:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dayOfTheWeek</span><span class="params">(<span class="type">int</span> day, <span class="type">int</span> month, <span class="type">int</span> year)</span> &#123;</span><br><span class="line">        String[] week =&#123;<span class="string">&quot;Sunday&quot;</span>, <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// 1970的最后一天是星期四</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> day + <span class="number">4</span>;</span><br><span class="line">        <span class="comment">// 1970前一个闰年是1968年， -1是因为从上一年开始才算整年</span></span><br><span class="line">        ans += <span class="number">365</span> * (year - <span class="number">1971</span>) + ((year - <span class="number">1</span>) - <span class="number">1968</span>) / <span class="number">4</span>;</span><br><span class="line">        <span class="type">int</span>[] day4month = &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; month - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            ans += day4month[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (((year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> !=<span class="number">0</span>) || (year % <span class="number">400</span> == <span class="number">0</span>)) &amp;&amp; month &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> week[ans % <span class="number">7</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img src="/../images/1185%E6%96%B9%E6%A1%882.png" alt="1185方案2"></p>
<p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = &#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        ans[<span class="number">0</span>] = binarySearch(nums,target,<span class="literal">true</span>);</span><br><span class="line">        ans[<span class="number">1</span>] = binarySearch(nums,target,<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, <span class="type">boolean</span> isLeft)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                <span class="keyword">if</span>(isLeft)&#123;</span><br><span class="line">                    <span class="comment">//如果要找的是最左边的，让右区间往左移一位</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//如果要找的是最右边的，让左区间往右移一位</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><a href="https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/">1576. 替换所有的问号</a></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">modifyString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">char</span>[] ss = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ss[i] == <span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; <span class="number">26</span>;j++)&#123;</span><br><span class="line">                    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span> + j);</span><br><span class="line">                    <span class="keyword">if</span>((i - <span class="number">1</span> &lt; <span class="number">0</span> || ss[i - <span class="number">1</span>] != c) &amp;&amp; (i + <span class="number">1</span> &gt;= n || ss[i + <span class="number">1</span>] != c))&#123;</span><br><span class="line">                        ss[i] = c;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(ss);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>推送系统的容灾建设与实践</title>
    <url>/posts/1039209453.html</url>
    <content><![CDATA[<p>本文介绍了推送系统容灾建设和关键技术方案，以及实践过程中的思考与挑战.</p>
<h2 id="推送系统介绍"><a href="#推送系统介绍" class="headerlink" title="推送系统介绍"></a>推送系统介绍</h2><p>vivo推送平台是vivo公司向开发者提供的消息推送服务，通过在云端与客户端之间建立一条稳定、可靠的长连接，为开发者提供向客户端应用实时推送消息的服务，支持百亿级的通知&#x2F;消息推送，秒级触达移动用户。</p>
<p>推送系统主要由接入网关，逻辑推送节点，长连接组成，长连接负责与用户手机终端建立连接，及时把消息送达到手机终端。</p>
<p>推送系统的<strong>特点</strong>是<strong>并发高、消息量大、送达及时性较高</strong>。</p>
<p>vivo推送系统现状最高推送速度140w&#x2F;s，单日最大消息量200亿，端到端秒级在线送达率99.9%。同时推送系统具备不可提前预知的突发大流量特点。针对推送系统高并发，高时效，突发流量等特点，如何保证系统可用性呢？本文将从系统架构，存储容灾，流量容灾三个方面进行讲述，推送系统是如何做容灾的。</p>
<h2 id="系统架构容灾方案"><a href="#系统架构容灾方案" class="headerlink" title="系统架构容灾方案"></a>系统架构容灾方案</h2><h3 id="长连接层容灾"><a href="#长连接层容灾" class="headerlink" title="长连接层容灾"></a>长连接层容灾</h3><p>长连接是推送系统最重要的部分，长连接的稳定性直接决定了推送系统的推送质量和性能，因此，需要对长连接层做好容灾和实时调度能力。</p>
<p>原有推送系统架构是长连接层都部署在华东，所有vivo IDC逻辑节点通过VPC与华东的Broker建立连接，手机端跟华东的broker进行长连接通信。这种部署方式存在以下<strong>问题</strong>:</p>
<ul>
<li><strong>问题一：</strong>华北、华南手机都需要连接华东的Broker，地域跨度大，长连接网络稳定性和时效性相对较差。</li>
<li><strong>问题二：</strong>逻辑层跟华东的Broker之间由一条VPC连接，随着业务的发展，推送流量越来越大，带宽会出现瓶颈，有超限丢包的风险。另外当该VPC出现故障时，会造成全网消息无法送达。</li>
</ul>
<blockquote>
<p>注：长连接层节点名为Broker。</p>
</blockquote>
<p><strong>原始长连接架构图：</strong></p>
<p><img src="/../images/%E5%8E%9F%E5%A7%8B%E9%95%BF%E8%BF%9E%E6%8E%A5%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="原始长连接架构图"></p>
<p>基于以上架构存在问题，进行了优化，将Broker进行三地部署，分别部署在华北，华东，华南。</p>
<p>华北、华东、华南三地用户采用就近接入方式。</p>
<p>优化后的架构，不仅可以保证长连接网络稳定性和时效性。同时具有较强的容灾能力，华东，华南Broker通过云网跟华北Broker连接，华北Broker通过VPC与vivo IDC连接。当华北、华东、华南某个地区Broker集群故障或者公网故障，不会影响到全网设备收发消息。但是这种方式还是存在一个问题，就是某个地区Broker集群故障或者公网故障，会出现该区域部分设备无法收到推送消息的情况。</p>
<p><strong>三地部署后的架构图：</strong></p>
<p><img src="/../images/%E4%B8%89%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%90%8E%E7%9A%84%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="三地部署后的架构图"></p>
<p>针对上述单个地区异常导致该区域部分设备无法收到推送消息的问题，我们设计了一套流量调度系统，可以做到实时流量调度和切换。global scheduler节点负责策略调度和管理。</p>
<p>vivo phone进行注册时，dispatcher会下发多个地区的ip地址，默认情况下，进行就近连接。单多次连接失败后，尝试连接其他ip。当某个地区Broker出现长连接数瓶颈或者VPC出现故障，可以通过global scheduler节点下发策略，让该故障地区的设备重新从dispatcher获取新的ip集的ip，与其他地区Broker建立长连接，逻辑节点下发消息到重连后的Broker。等到该地区恢复后，可以重新再下发策略，进行回调。</p>
<p><strong>流量调度系统图：</strong></p>
<p><img src="/../images/%E6%B5%81%E9%87%8F%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F%E5%9B%BE.png" alt="流量调度系统图"></p>
<h3 id="逻辑层容灾"><a href="#逻辑层容灾" class="headerlink" title="逻辑层容灾"></a>逻辑层容灾</h3><p>长连接层做好容灾后，逻辑层也需要做相应容灾。之前我们逻辑层都部署在一个机房，不具备机房间容灾能力，当一个机房出现断电风险，会出现服务整体不可用问题，因此我们做”同城双活”部署方案改造。</p>
<p><strong>逻辑层单活架构：</strong></p>
<p><img src="/../images/%E9%80%BB%E8%BE%91%E5%B1%82%E5%8D%95%E6%B4%BB%E6%9E%B6%E6%9E%84.png" alt="逻辑层单活架构"></p>
<p>逻辑层分别在vivo IDC1和vivo IDC2进行部署，网关层根据路由规则将流量按照一定比例分别下发到两个IDC，实现逻辑层同城双活。我们发现，数据中心还是只有一个，部署在vivo IDC1，根据成本、收益，以及多数据中心数据同步延迟问题综合考虑，数据中心暂时还是以单数据中心为主。</p>
<p><strong>逻辑层双活架构：</strong></p>
<p><img src="/../images/%E9%80%BB%E8%BE%91%E5%B1%82%E5%8F%8C%E6%B4%BB%E6%9E%B6%E6%9E%84.png" alt="逻辑层双活架构"></p>
<h2 id="流量容灾方案"><a href="#流量容灾方案" class="headerlink" title="流量容灾方案"></a>流量容灾方案</h2><p>做好系统架构的容灾能力后，推送系统的网关层还需要应对突发流量做相应的应对措施，做好流量控制，保证系统稳定性。历史上，我们曾经因为热点和突发新闻事件，并发推送流量巨大，导致服务出现异常，可用性降低问题。</p>
<p>如何应对突发大流量，保证突发流量的情况下，系统可用性不变，同时能兼顾性能和成本。为此，我们分别对比了设计了以下两种方案。</p>
<p>常规的方案是一般是根据历史情况估算冗余部署大量机器，来应对突发流量。单这种方式成本较高，突发流量可能只持续5分钟或更短时间，而系统为了满足5分钟突发流量，需要冗余部署大量机器。一旦流量超过了部署机器可承担的上限，无法及时扩容，可能导致可用性下降，甚至出现雪崩效应。</p>
<p><strong>传统方案下的推送架构：</strong></p>
<p><img src="/../images/%E4%BC%A0%E7%BB%9F%E6%8E%A8%E9%80%81%E6%9E%B6%E6%9E%84.png" alt="传统推送架构"></p>
<p><strong>那如何设计一套既可以控制成本，面对突发大流量弹性扩容，又保证消息不漏并兼顾推送性能的方案呢？</strong></p>
<p><strong>优化方案：</strong>在原有架构的基础上，在接入层增加缓冲通道，当流量洪峰到来时，对于系统可处理的上限能力外的流量，打入缓冲队列。通过消息队列形式，增加bypass接入层，限速消费消息队列。在流量洪峰过去后，提升bypass消费速度，处理缓存队列消息。bypass接入层通过docker部署，支持动态扩缩容，默认最小化集群，当消息队列积压很多，并且下游有能力处理时，提升消费速度，bypass根据CPU负载动态扩容，快速消费消息队列。处理完毕后动态缩容。</p>
<p><strong>消息队列：</strong>选用吞吐量较大的KAFKA中间件，并且与离线计算KAFKA集群共用，能充分利用资源。</p>
<p><strong>bypass接入层：</strong>采用docker部署，支持根据CPU负载和时间动态扩缩容。默认最小集群部署。对于已知的流量高峰时段，可以提前扩容服务，保证流量快速处理。未知时段流量高峰，可以bypass接入层，根据CPU负载情况进行动态扩缩容。</p>
<p><strong>增加缓存队列后的推送架构：</strong></p>
<p><img src="/../images/%E7%BC%93%E5%AD%98%E9%98%9F%E5%88%97%E5%90%8E%E7%9A%84%E6%8E%A8%E9%80%81%E6%9E%B6%E6%9E%84.png" alt="缓存队列后的推送架构"></p>
<p>进行上述改造后，还存在一个问题，就是如何进行接入层全局控速。我们采用的方式是收集下游推送节点的推送流量情况，比如：流量达到系统可承受上限的80%时下发限速指令，调整接入层推送速度。让消息先积压在消息队列，等到下游流量降低之后，下发解除限速指令，让bypass接入层加速消费消息队列，进行推送。</p>
<p><strong>增加控速后的推送架构：</strong></p>
<p><img src="/../images/%E5%A2%9E%E5%8A%A0%E6%8E%A7%E9%80%9F%E5%90%8E%E7%9A%84%E6%8E%A8%E9%80%81%E6%9E%B6%E6%9E%84.png" alt="增加控速后的推送架构"></p>
<p><strong>优化后方案与传统方案对比：</strong></p>
<p><img src="/../images/%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94.png" alt="方案对比"></p>
<h2 id="存储容灾方案"><a href="#存储容灾方案" class="headerlink" title="存储容灾方案"></a>存储容灾方案</h2><p>做好并发流量控制后，能很好的预发突发热点问题。推送系统内部，由于使用Redis集群缓存消息，出现过因为Redis集群故障导致消息无法及时送达问题。因此，我们考虑对Redis集群做相关容灾方案设计，实现系统在Redis集群故障期间，也能及时推送消息并保证消息不丢失。</p>
<p>推送消息体缓存在Redis集群中，推送时从Redis中获取消息体，如果Redis集群宕机，或者内存故障，会导致离线消息体丢失。</p>
<p><strong>原有消息流程：</strong></p>
<p><img src="/../images/%E5%8E%9F%E6%9C%89%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8B.png" alt="原有消息流程"></p>
<p><strong>方案一：</strong>引入另一个对等Redis集群，采用推送双写方式，双写两个Redis集群。该方案需要冗余部署规模对等的备Redis集群。推送系统需要双写Redis操作。</p>
<p><img src="/../images/%E6%96%B9%E6%A1%881.png" alt="方案1"></p>
<p><strong>方案二：</strong>原有Redis集群，采用RDB+AOF方式同步到另一个备Redis集群。该方案不在需要推送系统双写Redis改造，直接利用将原有Redis集群数据同步到另一个备Redis集群。也需要冗余部署规模对等的备Redis集群。可能存在部分数据同步延迟导致推送失败问题。</p>
<p><img src="/../images/%E6%96%B9%E6%A1%882.png" alt="方案2"></p>
<p><strong>方案三：</strong>应用另一个分布式存储系统，磁盘KV，兼容Redis协议，同时具有持久化能力。可以保证消息体不丢失。但是为了节省成本，不再直接使用Redis集群对等资源。而是根据推送特点，推送分为单推、群推。单推是一对一推送，一个用户一条消息体。群推是一对多推送，一个消息体对应多个用户。群推往往是任务级别推送。因此我们使用一个相对小一些的磁盘KV集群，主要用于冗余存储，群推消息体，即任务级别的消息。对于单推，还是只保存到Redis中，不进行冗余存储。</p>
<p>如果Redis集群故障，对于单推消息，推送系统可以携带消息体往下游推送，确保消息可以继续下发。对于群推消息，因为消息体冗余存储在磁盘KV中，当Redis集群故障后，可以降级到读取磁盘KV。</p>
<p><img src="/../images/%E6%96%B9%E6%A1%883.png" alt="方案3"></p>
<p>方案三还存在一个问题，就是磁盘KV的写入性能和Redis集群不是一个数量级，特别是时延，磁盘KV在平均在5ms左右。而Redis集群却在0.5ms。如果在推送系统对群推消息体进行双写。这个时延是不能接受的。因此只能采用异步写入磁盘KV的方式。这里将备份群推消息体，先写入消息中间件KAFKA，由bypass节点消费KAKFA进行异步写入磁盘KV。这样在使用的灾备磁盘KV资源较少的前提下，保证推送系统的高并发能力，同时可以保证群推消息体不丢失，Redis异常时，单推消息携带消息体推送，群推消息体读取磁盘KV。</p>
<p><img src="/../images/%E7%A3%81%E7%9B%98KV%E6%96%B9%E6%A1%88.png" alt="磁盘KV方案"></p>
<p><strong>存储容灾方案对比：</strong></p>
<p><img src="/../images/%E5%AD%98%E5%82%A8%E5%AE%B9%E7%81%BE%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94.png" alt="存储容灾方案对比"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从系统架构容灾、流量容灾、存储容灾三个方面讲述了推送系统容灾建设过程。系统容灾需要根据业务发展，成本收益，实现难度等多方面考虑。</p>
<p>当前长连接层已具备三地部署，逻辑层具备同城双活，数据中心为单数据中心。</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>推送系统</tag>
      </tags>
  </entry>
  <entry>
    <title>解密游戏推荐系统的建设之路</title>
    <url>/posts/862342694.html</url>
    <content><![CDATA[<p>本文从零开始介绍了游戏推荐项目的发展历程，阐述了大型项目建设中遇到的业务与架构问题以及开发工程师们的解决方案，描绘了游戏推荐项目的特点以及业务发展方向，有着较好的参考与借鉴意义。</p>
<h2 id="游戏推荐的背景与意义"><a href="#游戏推荐的背景与意义" class="headerlink" title="游戏推荐的背景与意义"></a>游戏推荐的背景与意义</h2><p>从信息获取的角度来看，搜索和推荐是用户获取信息的两种主要手段，也是有效帮助产品变现的两种方式，搜索是一个非常主动的行为，并且用户的需求十分明确，在搜索引擎提供的结果里，用户也能通过浏览和点击来明确的判断是否满足了用户需求。</p>
<p>然而，推荐系统接受信息是被动的，需求也都是模糊而不明确的。推荐系统的<strong>作用</strong>就是建立更加有效率的连接，更有效率地连接用户与内容和服务，节约大量的时间和成本。以此背景，游戏推荐系统由此诞生。<br> <img src="/../images/%E6%B8%B8%E6%88%8F%E9%A6%96%E9%A1%B5.png" alt="游戏首页">   </p>
<p>游戏推荐系统从设计之初就作为游戏分发的平台，向公司内所有主要流量入口（游戏中心、应用商店、浏览器、jovi等）分发游戏，系统通过各种推荐算法及推荐策略，为用户推荐下载付费意愿较高且兼顾商业价值的游戏，从而为公司带来收入。发展至今天，该系统还具备类游戏内容与素材的推荐功能。</p>
<h2 id="游戏推荐的初期模型"><a href="#游戏推荐的初期模型" class="headerlink" title="游戏推荐的初期模型"></a>游戏推荐的初期模型</h2><p>游戏推荐的目的是推出用户想要且兼顾商业价值的游戏，以此来提高业务的收入指标。此处的商业价值是由运营侧通过策略规则去把控的，而用户意向游戏则是通过算法排序得到的，算法排序所需要的特征数据，以及推荐效果的反馈数据则由埋点信息上报以供计算分析。</p>
<p>因此我们的模型可以分成四大块：</p>
<ol>
<li>运营推荐规则配置</li>
<li>算法模型训练</li>
<li>推荐策略生效</li>
<li>数据埋点上报</li>
</ol>
<p> <img src="/../images/%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E5%88%9D%E6%9C%9F%E6%A8%A1%E5%9D%97.png" alt="推荐模型初期模块"></p>
<p>模块间的<strong>交互如下：</strong>在策略生效前，运营会先在配置中心生成对应的配置规则，这些规则会以缓存的形式存储以供推荐高并接口调用。当用户访问app应用某些特定页面时，其后台会带着对应的场景信息来请求游戏推荐后台，推荐后台根据场景信息映射相关配置（召回，标签，过期，算法等……….）调用算法服务并进行资源排序，最终将推荐的结果反馈给app应用。</p>
<p>app应用在展示推荐页面的同时，也将用户相应的行为数据以及推荐数据的相关埋点进行上报。</p>
<h2 id="业务增长与架构演进"><a href="#业务增长与架构演进" class="headerlink" title="业务增长与架构演进"></a>业务增长与架构演进</h2><p>随着接入系统带来的正向收益的提升，越来越多的业务选择接入游戏推荐系统，这使得我们支持的功能日益丰富。</p>
<p>目前游戏推荐覆盖的场景有分类、专题、榜单、首页、搜索等；包含的策略类型有干预、打散、资源配比、保量；支持的推荐类型更是丰富：联运游戏、小游戏、内容素材、推荐理由。</p>
<p>这些丰富的使用场景使得业务的复杂度成本增长，令我们在性能，扩展性，可用性上面临着新的挑战，也推动着我们架构变革。</p>
<h3 id="熵增环境下的通用组合策略"><a href="#熵增环境下的通用组合策略" class="headerlink" title="熵增环境下的通用组合策略"></a>熵增环境下的通用组合策略</h3><p>  在0 到 1 的过程中，游戏推荐聚焦于提高分发量，这时候考虑得更多的是怎么把游戏推出去，在代码实现上使用分层架构来划分执行的业务。</p>
<p>但是在1 到 2 的过程中， 我们游戏推荐不仅仅推荐游戏，也推荐内容和素材；同时在策略调用上也更加灵活，不同场景其调用的策略是不同的，执行顺序也是不同的；更重要的是加入了很多用户个性化业务与动态规则，这些都使得现有业务代码急剧膨胀，扩展起来捉襟见肘，无从下手。因此我们急需一个高复用，易扩展，低代码的策略框架去解决这些问题。</p>
<p><img src="/../images/%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B.png" alt="系统模型"></p>
<p>如图所示，通用组合策略负责流转的角色有两个acceptor和executor，通讯媒介是推荐上下文context。负责执行逻辑的角色有三个matcher，listener和process，它们都有多个不同逻辑的实现类。当请求游戏推荐系统时，acceptor会先从配置中动态查询策略模板进行匹配，接着listener组件会执行相应的预处理逻辑。处理后acceptor通过上下文context将任务流转给executor处理器。executor再根据配置，将process根据前置条件进行筛选并排列组合，最后埋点返回。</p>
<p>经过这套通用的策略，我们在实现一般业务的时候，只要扩展具体matcher和process，并在配置中心将场景和处理优先级绑定起来，就能完成大部分的场景开发，这样研发者可以更聚焦于某个逻辑流程的开发，而不用疲于梳理代码，并进行扩展设计。</p>
<h3 id="多级缓存与近实时策略"><a href="#多级缓存与近实时策略" class="headerlink" title="多级缓存与近实时策略"></a>多级缓存与近实时策略</h3><p>​    游戏推荐系统服务于手机游戏用户，处于整个系统链路的下游，峰值流量在3W TPS左右 ，是个读远多于写的系统。“读”流量来自于用户在各种推荐场景，列表、搜索、下载钱下载后、榜单等，写数据主要来源于运营相关策略的变更，<strong>所以我们面临的一个重大挑战就是如何在保证可用性的前提下应对高频的读请求。</strong></p>
<p>为了保证系统的读性能，我们采用了redis + 本地缓存的设计。配置更新后先写mysql，写成功后再写redis。本地缓存定时失效，使用懒加载的方式从redis中读取相关数据。这种设计能保证最终一致性，软状态时服务集群数据存在短暂不一致的情况，早期对业务影响不大，可以认为是一个逐步放量的过程。</p>
<p><img src="/../images/%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%981.png" alt="更新缓存1"></p>
<p>早期原先部署节点较少，整个系统达到最终一致性的时间较短，但随着节点增加到数百台，这个时间就变得不是那么和谐了。</p>
<p>同时随着业务复杂度的增加，常常是多个配置策略决定这一个推荐结果，此时本地缓存的状态极大影响了测试和点检的便利，如果配置更改不能做到立马更新本地缓存，那就要等待漫长的一段时间才能开始验证逻辑。因此，对缓存结构做出了如下的调整：</p>
<p><img src="/../images/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B02.png" alt="缓存更新2"></p>
<p>与先前不同的是，我们加入消息队列并通过配置版本号的比对来实现策略的实时更新同步，取得了很好的效果。</p>
<h3 id="高并服务的垃圾回收处理"><a href="#高并服务的垃圾回收处理" class="headerlink" title="高并服务的垃圾回收处理"></a>高并服务的垃圾回收处理</h3><p>任何一个java服务都逃离不了FGC的魔咒，高并服务更是如此。很多服务每天两位数的FGC更是家常便饭，显然这对业务的稳定性和服务性能影响是巨大的。游戏推荐这边通过不断实践总结了一套较为通用的方法很好地解决了这个问题：</p>
<p>![Full Gc](..&#x2F;images&#x2F;Full Gc.png)</p>
<p>可以看到起初jvm配置较为常规：1G的年轻代，2G的老年代以及一些其他常见的多线程回收的配置，其结果就是每天10次的FGC，YGC单次耗时在100ms，FGC耗时在350 - 400ms。我们知道线上接口容忍的范围一般是200ms以内，不超过300ms，这样显然是不达标的。</p>
<p>通过分析，我们发现高并服务的高频FGC来源于这几个方面：</p>
<ul>
<li>大量的本地缓存（堆内）占据了老年代的空间，大大增加了老年代叠满的频率。</li>
<li>高并请求导致了对象的急速生成，年轻代空间不足以容纳这剧增的对象，导致其未达到存活阈值（15次）就晋升至老年代。</li>
<li>引入的监控组件为了性能，常常延迟 1 - 2 min再将数据上报服务端，导致这部分数据也无法在年轻代被回收。</li>
</ul>
<p>当然这还不是问题的全部，FGC还有个致命问题就是stop the world，这会导致业务长时间无法响应，造成经济损失。反过来，就算FGC频繁，stop the world 只有1ms，也是不会对业务造成影响的，因此不能单单以FGC的频率来判断jvm服务的gc性能的好坏。经过上面的探讨，我们在实践中得到了如下的解决方案：</p>
<ul>
<li><p>不常变化的缓存（小时级别）移到堆外，以此减少老年代叠满的基础阈值。</p>
</li>
<li><p>变化不那么频繁的缓存（分钟级别）更新的时候进行值对比，如果值一样则不更新，以此减少老年代的堆积。</p>
</li>
<li><p>使用G1回收器：-XX:+UseG1GC</p>
<p>-XX:MaxGCPauseMillis&#x3D;200</p>
<p>-XX:InitiatingHeapOccupancyPercent&#x3D;25</p>
<p>-XX:MaxNewSize&#x3D;3072M -Xms4608M -Xmx4608M -XX:MetaspaceSize&#x3D;512M</p>
<p>-XX:MaxMetaspaceSize&#x3D;512M</p>
</li>
</ul>
<p> 其效果如上所示，调整后各项指标都有很大的进步：由于年轻代中的复制算法使其垃圾清理速度较快，所以调大其容量使对象尽量在其中回收，同时设置每次清理的时间，使得mix gc控制在200ms以内。</p>
<p><img src="/../images/G1%E5%9E%83%E5%9C%BE%E4%BC%98%E5%8C%96.png" alt="G1垃圾优化"></p>
<p>其效果如上所示，调整后各项指标都有很大的进步：由于年轻代中的复制算法使其垃圾清理速度较快，所以调大其容量使对象尽量在其中回收，同时设置每次清理的时间，使得mix gc控制在200ms以内。</p>
<h3 id="限流降级与兜底策略"><a href="#限流降级与兜底策略" class="headerlink" title="限流降级与兜底策略"></a>限流降级与兜底策略</h3><p>为了保证业务的可用性，大部分业务都会引入hystrix, sentinel, resilience4j 这类熔断限流组件， 但这些组件也不能解决全部的问题。</p>
<p>对于游戏推荐来说，一台节点往往承载着不同的业务推荐，有些业务十分核心，有些不是那么重要，限流降级的时候不是简单的哪个服务限流多少问题，而是在权衡利弊的情况下，将有限的资源向哪些业务倾斜的问题，对此我们在分层限流上下足了功夫。  </p>
<p><img src="/../images/%E9%99%90%E6%B5%81%E6%A8%A1%E5%9E%8B%E5%9B%BE.png" alt="限流模型图"></p>
<p>同时对于个性化业务来说，仅仅返回通用的兜底会使推荐同质化，因此我们的策略是将用户的历史数据存储下来，并在下次兜底的时候作为推荐列表进行返回。</p>
<p><img src="/../images/%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B.png" alt="请求过程"></p>
<h2 id="精细化运营模式的探索"><a href="#精细化运营模式的探索" class="headerlink" title="精细化运营模式的探索"></a>精细化运营模式的探索</h2><p>在经历过了0 到1 的开疆拓土 与 1 到 2 的高速增长后，游戏的推荐架构已经趋于稳定。这时候我们更加关注效能的提高与成本的下降，因此我们开始着手于<strong>系统运营的精细化设计</strong>，这对推荐系统的良性发展是意义重大的。</p>
<p>精细化运营不仅能提高尾量游戏的收入，提高运营人员的工作效率，还能实时快速反馈算法在线效果并立马做出调整，做到一个业务上的闭环。首先就不得不提到游戏推荐系统的分层正交实验平台，这是我们做精细化运营的基础。</p>
<h3 id="多层-hash-正交实验平台"><a href="#多层-hash-正交实验平台" class="headerlink" title="多层 hash 正交实验平台"></a>多层 hash 正交实验平台</h3><p>游戏推荐的关键就一个”准”字，这就需要通过精细化策略迭代来提升效率和准确度，从而不断扩大规模优势，实现正向循环。然而策略的改变并不是通过“头脑风暴”空想的，而是一种建立在数据反馈上的机制，以带来预期内的正向变化。这就需要我们分隔对照组来做A&#x2F;Btest。</p>
<p>一般线上业务常见的A&#x2F;B test是通过物理方式对流量进行隔离，这种方法常见于H5页面的分流实验，但面对复杂业务时却存在着部署较慢，埋点解析困难等问题，其典型的架构方式如下：</p>
<p><img src="/../images/%E5%AE%9E%E9%AA%8C%E5%88%86%E6%B5%81%E6%9E%B6%E6%9E%84.png" alt="实验分流架构"></p>
<p>对于游戏推荐来说，其完成一次推荐请求的流程比较复杂，涉及到多组策略，为了保证线上流量的效率与互斥，就不能采用简单的物理分配流量的方式。</p>
<p>因此在业务层我们建立了一套多层hash正交实验规则来满足我们A&#x2F;B test的要求。</p>
<p>与物理隔离流量，部署多套环境的方式不同，分层模型在分流算法中引入层级编号因子（A）来解决流量饥饿和流量正交问题。每一实验层可以划分为多个实验田，当流量经过每一层实验时，会先经过Function(Hash(A)) 来计算其分配的实验田，这样就能保证层与层之间的流量随机且相互独立。其流量走势如下图所示: </p>
<p><img src="/../images/hash%E5%AE%9E%E9%AA%8C%E5%88%86%E5%B1%82.png" alt="hash实验分层"></p>
<p>以上就是推荐业务和一般业务实验流量隔离的不同之处，在实验设计上我们又将一个完整的实验周期分为以下几个阶段。在预备阶段需要跟根据业务指标的需求，提出实验假设，划分好基线和实验田的流量比例，并上线配置（放量）。</p>
<p>在实验阶段，线上流量进入后，服务会根据流量号段的匹配响应的策略进行执行，并将实验数据上报。放量一段时候后，我们会根据上报的埋点数据进行数据分析，以确定此次策略的好坏。</p>
<p><img src="/../images/%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B.png" alt="实验过程"></p>
<p>和实验阶段划分相对应地，我们将实验平台划分为实验配置，埋点上报和实验结果分析三个模块，在实验配置模块，我们根据实验需求来完成分流配置和业务场景的映射关系。</p>
<p><img src="/../images/%E5%90%8E%E5%8F%B0%E5%88%86%E6%B5%81%E9%85%8D%E7%BD%AE.png" alt="后台分流配置"></p>
<p>并在hash实验管理中将业务层级划分，以便流量的流通。</p>
<p><img src="/../images/hash%E5%AE%9E%E9%AA%8C%E9%85%8D%E7%BD%AE.png" alt="hash实验配置"></p>
<p>在埋点上报模块中，我们通过sdk的方式植入业务代码中，当流量进入该实验田时就会进行分析和埋点上报，我们将上报的埋点分为游戏和请求维度，节省上报流量的同时以满足不同的分析需求：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JSON"><figure class="iseeu highlight /json"><table><tr><td class="code"><pre><span class="line">游戏维度：</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;score&quot;</span><span class="punctuation">:</span> <span class="number">0.016114970572330977</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;gameId&quot;</span><span class="punctuation">:</span> <span class="number">53154</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;appId&quot;</span><span class="punctuation">:</span> <span class="number">1364982</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;recommendReason&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;gameps&quot;</span><span class="punctuation">:</span> <span class="string">&quot;埋点信息&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;reqId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;20200810174423TBSIowaU52fjwjjz&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">请求维度：</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;reqId&quot;</span><span class="punctuation">:</span><span class="string">&quot;20200810142134No5UkCibMdAvopoh&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;scene&quot;</span><span class="punctuation">:</span> <span class="string">&quot;appstore.idx&quot;</span><span class="punctuation">,</span>                       </span><br><span class="line">    <span class="attr">&quot;imei&quot;</span><span class="punctuation">:</span> <span class="string">&quot;869868031396914&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;experimentInfo&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;experimentId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;RECOMMENDATION_SCENE&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;salt&quot;</span><span class="punctuation">:</span><span class="string">&quot;RECOMMENDATION_SCENE&quot;</span><span class="punctuation">,</span>         </span><br><span class="line">            <span class="attr">&quot;imei&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3995823625&quot;</span><span class="punctuation">,</span>                  </span><br><span class="line">            <span class="attr">&quot;sinfo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;策略信息&quot;</span>                               </span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;experimentId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AUTO_RECOMMENDATION_REASON&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;salt&quot;</span><span class="punctuation">:</span><span class="string">&quot;RECOMMENDATION_SCENE&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;imei&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1140225751&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;sid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;3，4，5&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<p>在实验结果分析模块中，我们将采集的埋点的数据上报只大数据侧，并由其进行分析计算，其结果指导这我们对实验策略进行进一步的分析迭代。对于游戏请求的上报格式，我们可以直接通过appId和gameps的信息直接分析得出该类游戏的推荐结果和用户行为的关系。同时加入请求维度的分析（包含策略信息），可以直接分析出决策对各项指标的影响。</p>
<h3 id="召回优化之多路召回"><a href="#召回优化之多路召回" class="headerlink" title="召回优化之多路召回"></a>召回优化之多路召回</h3><p>召回在游戏推荐业务中就是利用一定的规则去圈选一批游戏，这是为了将海量的候选集快速缩小为几百到几千的规模。而召回之后的排序则是对缩小后的候选集进行精准排序，最终达到精准推荐的目的。</p>
<p>然而这种单路的召回在业务上却有着很大的<strong>缺陷</strong>：</p>
<ol>
<li>通常为了保证计算效率，圈选的数量在几百个左右，由于数量限制其无法完全覆盖完整的目标用户候选集。</li>
<li>随着业务的复杂度变高，召回策略的种类也开始膨胀，其召回规则是剥离的无法统一，这也意味着在某些业务场景下，在种类上无法覆盖完全。</li>
</ol>
<p><img src="/../images/%E5%8F%AC%E5%9B%9E%E6%8E%92%E5%BA%8F%E9%98%B6%E6%AE%B5.png" alt="召回排序阶段"></p>
<p>因此，权衡了计算效率和业务覆盖度（召回率）的问题，我们逐步上线了多路召回功能。</p>
<p>在业务实现上，多路召回兼容了原有的个性化召回、算法召回、游戏池召回、分类&#x2F;标签&#x2F;专题&#x2F;同开发者)召回等召回路径，通过圈选多个游戏池做为召回策略，经过合并、过滤、补量、截断等策略最终筛选出一批进行算法预估打分的游戏。</p>
<p>本质上，多路召回利用各简单策略保证候选集的快速召回，从不同角度设计的策略保证召回率接近理想状态。</p>
<p><img src="/../images/%E5%A4%9A%E8%B7%AF%E5%8F%AC%E5%9B%9E.png" alt="多路召回"></p>
<h3 id="曝光干预之动态调参"><a href="#曝光干预之动态调参" class="headerlink" title="曝光干预之动态调参"></a>曝光干预之动态调参</h3><p>一个推荐系统的效能如何，除了运营策略之外很大程度上取决于推荐算法的结果，而推荐算法的结果又是以曝光量，下载量，ctr等作为评价指标的。所以在游戏推荐业务的生命周期中，推荐算法一直致力于优化这些指标。</p>
<p>但是在开发中有个实际问题就是，从算法结果的数据反馈，到代码改进上线这个时间周期较长，对一些需要快速响应的业务场景来说是不符合要求的。因此我们需要一套规则来对线上的算法结果做动态调整，以满足业务的要求，这就是<strong>动态调参</strong>。</p>
<p>目前游戏业务的营收中，曝光量是个极其重要的指标，而大盘在一段时间内的曝光量是确定的，太多或太少都会严重影响业务，由此推荐算法就会根据线上实时反馈的一些数据对游戏的曝光进行调整。</p>
<p><img src="/../images/%E8%B0%83%E5%8F%82%E9%98%B6%E6%AE%B5.png" alt="调参阶段"></p>
<p>经过设计, 我们先将调参游戏划分为多个等级，并将游戏的生命周期划分为几个时间段，同时在每个时间段内以游戏曝光量，评级，数量等因素作为计算因子来计算曝光的分配权重。</p>
<p>接着系统根据实时采集的游戏曝光信息及所计算的游戏目标曝光对实际曝光进行调整，最终实现游戏曝光的动态调控。</p>
<p>对于正向调控来说，动态调参就是最有效的扶持机制，增加了游戏曝光的同时提升了导流能力。对于负向调控，动态调参能对品质和要求不达标的游戏，通过减少曝光的方式进行打压，提升用户体验。</p>
<h2 id="展望之智能化建设"><a href="#展望之智能化建设" class="headerlink" title="展望之智能化建设"></a>展望之智能化建设</h2><p>经过多年的探索实践，游戏推荐系统成就了一套完整的推荐体系。</p>
<p>在架构上的演进使得我们能更好地应对复杂多变的业务需求，在精细化运营上的探索与建设令我们能更加敏锐地把握住市场的变化以做出响应，这些建设也很好地反馈的反馈到了业务结果中，提升了众多效能和收益指标，得到了业务方的一致好评。</p>
<p>但当分发效率和收入效益问题解决了之后，我们在思考自己还能做什么，原先游戏推荐做的比较多的是接入服务，在单链路上去做闭环提高效益，但这是远远不够的。</p>
<p>在未来将会考虑如何打造覆盖搜广推+ 智能运营的全栈业务支撑系统（智能礼券，智能push，用户反馈智能处理系统），以提升平台和渠道的价值</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Jedis 参数异常引发服务雪崩案例分析</title>
    <url>/posts/1506681178.html</url>
    <content><![CDATA[<p>Redis 作为互联网业务首选的远程缓存工具而被大面积使用，作为访问客户端的 Jedis 同样被大面积使用。本文主要分析 Redis3.x 版本集群模式发生主从切换场景下 Jedis 的参数设置不合理引发服务雪崩的过程。</p>
<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>Redis作为互联网业务首选的远程缓存工具而被被大家熟知和使用，在客户端方面涌现了Jedis、Redisson、Lettuce等，而Jedis属于其中的佼佼者。</p>
<p>目前笔者的项目采用Redis的3.x版本部署的集群模式（多节点且每个节点存在主从节点），使用Jedis作为Redis的访问客户端。</p>
<p>日前Redis集群中的某节点因为宿主物理机故障导致发生主从切换，在主从切换过程中触发了Jedis的重试机制进而引发了服务的雪崩。</p>
<h2 id="故障现场记录"><a href="#故障现场记录" class="headerlink" title="故障现场记录"></a>故障现场记录</h2><p>本文旨在剖析Redis集群模式下节点发生主从切换进而引起服务雪崩的整个过程，希望能够帮助读者规避此类问题。</p>
<h3 id="消息堆积告警"><a href="#消息堆积告警" class="headerlink" title="消息堆积告警"></a>消息堆积告警</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="TXT"><figure class="iseeu highlight /txt"><table><tr><td class="code"><pre><span class="line">【MQ-消息堆积告警】</span><br><span class="line"></span><br><span class="line">-告警时间：2022-11-29 23:50:21</span><br><span class="line">-检测规则: 消息堆积阈值:-》异常( &gt; 100000)</span><br><span class="line">-告警服务：xxx-anti-addiction</span><br><span class="line">-告警集群：北京公共</span><br><span class="line">-告警对象：xxx-login-event-exchange/xxx-login-event-queue</span><br><span class="line">-异常对象(当前值): 159412</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>说明：</p>
<ul>
<li>2022-11-29 23:50:21收到一条RMQ消息堆积的告警，正常情况下服务是不会有这类异常告警，出于警觉性开始进入系统排查过程。</li>
<li>排查的思路基本围绕系统相关的指标：系统的请求量，响应时间，下游服务的响应时间，线程数等指标。</li>
</ul>
</blockquote>
<p><img src="/../images/%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87.png" alt="监控指标"></p>
<blockquote>
<p>说明：排查系统监控之后发现在故障发生时段服务整体的请求量有大幅下跌，响应的接口的平均耗时接近1分钟。</p>
</blockquote>
<p>服务整体出于雪崩状态，请求耗时暴涨导致服务不可用，进而导致请求量下跌。</p>
<p><img src="/../images/redis%E7%9B%91%E6%8E%A7.png" alt="redis监控"></p>
<blockquote>
<p>说明：排查服务的下游应用发现故障期间Redis的访问量大幅下跌，已趋近于0。</p>
</blockquote>
<p>项目中较长用的Redis的响应耗时基本上在2s。</p>
<p><img src="/../images/%E7%AD%89%E5%BE%85%E7%BA%BF%E7%A8%8B%E6%8C%87%E6%A0%87.png" alt="等待线程指标"></p>
<blockquote>
<p>说明：排查系统对应的线程数，发现在故障期间处于wait的线程数大量增加。</p>
</blockquote>
<p><img src="/../images/nginx%E6%8C%87%E6%A0%87.png" alt="nginx指标"></p>
<blockquote>
<p>说明：事后运维同学反馈在故障时间点Redis集群发生了主从切换，整体时间和故障时间较吻合。</p>
</blockquote>
<p><strong>综合各方面的指标信息，判定此次服务的雪崩主要原因应该是Redis主从切换导致，但是引发服务雪崩原因需要进一步的分析。</strong></p>
<h2 id="故障过程分析"><a href="#故障过程分析" class="headerlink" title="故障过程分析"></a>故障过程分析</h2><p>在进行故障的过程分析之前，首先需要对目前的现象进行分析，需要回答下面几个问题：</p>
<ul>
<li>接口响应耗时增加为何会引起请求量的陡降？</li>
<li>Redis主从切换期间大部分的耗时为啥是2s？</li>
<li>接口的平均响应时间为啥接近60s？</li>
</ul>
<h3 id="流量陡降"><a href="#流量陡降" class="headerlink" title="流量陡降"></a>流量陡降</h3><p><img src="/../images/nginx%E6%8C%87%E6%A0%87.png" alt="nginx指标"></p>
<blockquote>
<p>说明：通过nginx的日志可以看出存在大量的connection timed out的报错，可以归因为由于后端服务的响应时间过程导致nginx层和下游服务之间的读取超时。</p>
</blockquote>
<p>由于大量的读取超时导致nginx判断为后端的服务不可用，进而触发了no live upstreams的报错，ng无法转发到合适的后端服务。</p>
<p>通过nginx的日志可以将问题归因到后端服务异常导致整体请求量下跌。</p>
<h3 id="耗时问题"><a href="#耗时问题" class="headerlink" title="耗时问题"></a>耗时问题</h3><p><img src="/../images/redis%E8%80%97%E6%97%B6%E5%BC%82%E5%B8%B8.png" alt="redis耗时异常"></p>
<blockquote>
<p>说明：通过报错日志定位到Jedis在获取连接的过程中抛出了connect timed out的异常。</p>
</blockquote>
<p>通过定位Jedis的源码发现默认的设置连接超时时间 DEFAULT_TIMEOUT &#x3D; 2000。</p>
<p><img src="/../images/redis%E5%BC%82%E5%B8%B8%E9%87%8D%E8%AF%95.png" alt="redis异常重试"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAINTEXT"><figure class="iseeu highlight /plaintext"><table><tr><td class="code"><pre><span class="line">&lt;redis-cluster name=&quot;redisCluster&quot; timeout=&quot;3000&quot; maxRedirections=&quot;6&quot;&gt; // 最大重试次数为6</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;property name=&quot;maxTotal&quot; value=&quot;20&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;maxIdle&quot; value=&quot;20&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;minIdle&quot; value=&quot;2&quot; /&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line">&lt;/redis-cluster&gt;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>说明：通过报错日志定位Jedis执行了6次重试，每次重试耗时参考设置连接超时默认时长2s，单次请求约耗时12s。</p>
</blockquote>
<p><strong>排查部分对外接口，发现一次请求内部总共访问的Redis次数有5次，那么整体的响应时间会达到1m&#x3D;60s。</strong></p>
<p><strong>结合报错日志和监控指标，判定服务的雪崩和Jedis的连接重试机制有关，需要从Jedis的源码进一步进行分析。</strong></p>
<h2 id="Jedis-执行流程"><a href="#Jedis-执行流程" class="headerlink" title="Jedis 执行流程"></a>Jedis 执行流程</h2><h3 id="流程解析"><a href="#流程解析" class="headerlink" title="流程解析"></a>流程解析</h3><p><img src="/../images/Jedis%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90.png" alt="Jedis流程解析"></p>
<blockquote>
<p>说明：Jedis处理Redis的命令请求如上图所示，整体在初始化连接的基础上根据计算的slot槽位获取连接后发送命令进行执行。</p>
</blockquote>
<p>在获取连接失败或命令发送失败的场景下触发异常重试，重新执行一次命令。</p>
<p>异常重试流程中省略了重新获取Redis集群分布的逻辑，避免复杂化整体流程。</p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p><strong>（1）整体流程</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisCluster</span> <span class="keyword">extends</span> <span class="title class_">BinaryJedisCluster</span> <span class="keyword">implements</span> <span class="title class_">JedisCommands</span>,</span><br><span class="line">    MultiKeyJedisClusterCommands, JedisClusterScriptingCommands &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">set</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String value, <span class="keyword">final</span> String nxxx, <span class="keyword">final</span> String expx,</span></span><br><span class="line"><span class="params">      <span class="keyword">final</span> <span class="type">long</span> time)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JedisClusterCommand</span>&lt;String&gt;(connectionHandler, maxAttempts) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">execute</span><span class="params">(Jedis connection)</span> &#123;</span><br><span class="line">        <span class="comment">// 真正发送命令的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> connection.set(key, value, nxxx, expx, time);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.run(key); <span class="comment">// 通过run触发命令的执行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">JedisClusterCommand</span>&lt;T&gt; &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title function_">execute</span><span class="params">(Jedis connection)</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> T <span class="title function_">run</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="comment">// 执行带有重试机制的方法</span></span><br><span class="line">    <span class="keyword">return</span> runWithRetries(SafeEncoder.encode(key), <span class="built_in">this</span>.maxAttempts, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">JedisClusterCommand</span>&lt;T&gt; &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> T <span class="title function_">runWithRetries</span><span class="params">(<span class="type">byte</span>[] key, <span class="type">int</span> attempts, <span class="type">boolean</span> tryRandomNode, <span class="type">boolean</span> asking)</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (asking) &#123;</span><br><span class="line">        <span class="comment">// 省略相关的代码逻辑</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRandomNode) &#123;</span><br><span class="line">          connection = connectionHandler.getConnection();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 1、尝试获取连接</span></span><br><span class="line">          connection = connectionHandler.getConnectionFromSlot(JedisClusterCRC16.getSlot(key));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 2、执行JedisClusterCommand封装的execute命令</span></span><br><span class="line">      <span class="keyword">return</span> execute(connection);</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">catch</span> (JedisNoReachableClusterNodeException jnrcne) &#123;</span><br><span class="line">      <span class="keyword">throw</span> jnrcne;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JedisConnectionException jce) &#123;</span><br><span class="line">      <span class="comment">// 省略代码</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      releaseConnection(connection);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>说明：以JedisCluster执行set命令为例，封装成JedisClusterCommand对象通过run触发runWithRetries进而执行set命令的execute方法。</p>
</blockquote>
<p>runWithRetries方法封装了具体的重试逻辑，内部通过connectionHandler.getConnectionFromSlot</p>
<p>获取对应的Redis节点的连接。</p>
<p><strong>（2）计算槽位</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">JedisClusterCRC16</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSlot</span><span class="params">(<span class="type">byte</span>[] key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">sFound</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; key.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key[i] == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; !sFound) &#123;</span><br><span class="line">        s = i;</span><br><span class="line">        sFound = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (key[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; sFound) &#123;</span><br><span class="line">        e = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s &gt; -<span class="number">1</span> &amp;&amp; e &gt; -<span class="number">1</span> &amp;&amp; e != s + <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> getCRC16(key, s + <span class="number">1</span>, e) &amp; (<span class="number">16384</span> - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getCRC16(key) &amp; (<span class="number">16384</span> - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>说明：Redis集群模式下通过计算slot槽位来定位具体的Redis节点的连接，Jedis通过JedisClusterCRC16.getSlot(key)来获取slot槽位。</p>
</blockquote>
<p>Redis的集群模式的拓扑信息在Jedis客户端同步维护了一份，具体的slot槽位计算在客户端实现。</p>
<p><strong>（3）连接获取</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisSlotBasedConnectionHandler</span> <span class="keyword">extends</span> <span class="title class_">JedisClusterConnectionHandler</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Jedis <span class="title function_">getConnectionFromSlot</span><span class="params">(<span class="type">int</span> slot)</span> &#123;</span><br><span class="line">    <span class="type">JedisPool</span> <span class="variable">connectionPool</span> <span class="operator">=</span> cache.getSlotPool(slot);</span><br><span class="line">    <span class="keyword">if</span> (connectionPool != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 尝试获取连接</span></span><br><span class="line">      <span class="keyword">return</span> connectionPool.getResource();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      renewSlotCache();</span><br><span class="line">      connectionPool = cache.getSlotPool(slot);</span><br><span class="line">      <span class="keyword">if</span> (connectionPool != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> connectionPool.getResource();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getConnection();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JedisFactory</span> <span class="keyword">implements</span> <span class="title class_">PooledObjectFactory</span>&lt;Jedis&gt; &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> PooledObject&lt;Jedis&gt; <span class="title function_">makeObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 1、创建Jedis连接</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">HostAndPort</span> <span class="variable">hostAndPort</span> <span class="operator">=</span> <span class="built_in">this</span>.hostAndPort.get();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(hostAndPort.getHost(), hostAndPort.getPort(), connectionTimeout,</span><br><span class="line">        soTimeout, ssl, sslSocketFactory, sslParameters, hostnameVerifier);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 2、尝试进行连接</span></span><br><span class="line">      jedis.connect();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JedisException je) &#123;</span><br><span class="line">      jedis.close();</span><br><span class="line">      <span class="keyword">throw</span> je;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultPooledObject</span>&lt;Jedis&gt;(jedis);</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Connection</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span> &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isConnected()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        socket = <span class="keyword">new</span> <span class="title class_">Socket</span>();</span><br><span class="line">        socket.setReuseAddress(<span class="literal">true</span>);</span><br><span class="line">        socket.setKeepAlive(<span class="literal">true</span>); <span class="comment">// Will monitor the TCP connection is</span></span><br><span class="line">        socket.setTcpNoDelay(<span class="literal">true</span>); <span class="comment">// Socket buffer Whetherclosed, to</span></span><br><span class="line">        socket.setSoLinger(<span class="literal">true</span>, <span class="number">0</span>); <span class="comment">// Control calls close () method,</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 1、设置连接超时时间 DEFAULT_TIMEOUT = 2000;</span></span><br><span class="line">        socket.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(host, port), connectionTimeout);</span><br><span class="line">        <span class="comment">// 2、设置读取超时时间</span></span><br><span class="line">        socket.setSoTimeout(soTimeout);</span><br><span class="line"> </span><br><span class="line">        outputStream = <span class="keyword">new</span> <span class="title class_">RedisOutputStream</span>(socket.getOutputStream());</span><br><span class="line">        inputStream = <span class="keyword">new</span> <span class="title class_">RedisInputStream</span>(socket.getInputStream());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        broken = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JedisConnectionException</span>(ex);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>说明：Jedis通过connectionPool维护和Redis的连接信息，在可复用的连接不够的场景下会触发连接的建立和获取。</p>
</blockquote>
<p>创建连接对象通过封装成Jedis对象并通过connect进行连接，在Connection的connect的过程中设置<strong>连接超时connectionTimeout和读取超时soTimeout</strong>。</p>
<p><strong>建立连接过程中如果异常会抛出</strong></p>
<p><strong>JedisConnectionException异常</strong>，注意这个异常会在后续的分析中多次出现。</p>
<p><strong>（4）发送命令</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Connection</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">protected</span> Connection <span class="title function_">sendCommand</span><span class="params">(<span class="keyword">final</span> Command cmd, <span class="keyword">final</span> <span class="type">byte</span>[]... args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 1、必要时尝试连接</span></span><br><span class="line">      connect();</span><br><span class="line">      <span class="comment">// 2、发送命令</span></span><br><span class="line">      Protocol.sendCommand(outputStream, cmd, args);</span><br><span class="line">      pipelinedCommands++;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JedisConnectionException ex) &#123;</span><br><span class="line">      broken = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendCommand</span><span class="params">(<span class="keyword">final</span> RedisOutputStream os, <span class="keyword">final</span> <span class="type">byte</span>[] command,</span></span><br><span class="line"><span class="params">      <span class="keyword">final</span> <span class="type">byte</span>[]... args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 按照redis的命令格式发送数据</span></span><br><span class="line">      os.write(ASTERISK_BYTE);</span><br><span class="line">      os.writeIntCrLf(args.length + <span class="number">1</span>);</span><br><span class="line">      os.write(DOLLAR_BYTE);</span><br><span class="line">      os.writeIntCrLf(command.length);</span><br><span class="line">      os.write(command);</span><br><span class="line">      os.writeCrLf();</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> <span class="type">byte</span>[] arg : args) &#123;</span><br><span class="line">        os.write(DOLLAR_BYTE);</span><br><span class="line">        os.writeIntCrLf(arg.length);</span><br><span class="line">        os.write(arg);</span><br><span class="line">        os.writeCrLf();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JedisConnectionException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>说明：Jedis通过sendCommand向Redis发送Redis格式的命令。</p>
</blockquote>
<p>发送过程中会执行connect连接动作，逻辑和获取连接时的connect过程一致。</p>
<p>发送命令异常会抛出JedisConnectionException的异常信息。</p>
<p><strong>（5）重试机制</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">JedisClusterCommand</span>&lt;T&gt; &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> T <span class="title function_">runWithRetries</span><span class="params">(<span class="type">byte</span>[] key, <span class="type">int</span> attempts, <span class="type">boolean</span> tryRandomNode, <span class="type">boolean</span> asking)</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (asking) &#123;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRandomNode) &#123;</span><br><span class="line">          connection = connectionHandler.getConnection();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 1、尝试获取连接</span></span><br><span class="line">          connection = connectionHandler.getConnectionFromSlot(JedisClusterCRC16.getSlot(key));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 2、通过连接执行命令</span></span><br><span class="line">      <span class="keyword">return</span> execute(connection);</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">catch</span> (JedisNoReachableClusterNodeException jnrcne) &#123;</span><br><span class="line">      <span class="keyword">throw</span> jnrcne;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (JedisConnectionException jce) &#123;</span><br><span class="line">      releaseConnection(connection);</span><br><span class="line">      connection = <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">// 4、重试到最后一次抛出异常</span></span><br><span class="line">      <span class="keyword">if</span> (attempts &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.connectionHandler.renewSlotCache();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">throw</span> jce;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 3、进行第一轮重试</span></span><br><span class="line">      <span class="keyword">return</span> runWithRetries(key, attempts - <span class="number">1</span>, tryRandomNode, asking);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      releaseConnection(connection);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>说明：Jedis执行Redis的命令时按照先获取connection后通过connection执行命令的顺序。</p>
</blockquote>
<p>在获取connection和通过connection执行命令的过程中如果发生异常会进行重试且在达到最大重试次数后抛出异常。</p>
<p>以attempts&#x3D;5为例，如果在获取connection过程中发生异常，那么最多重试5次后抛出异常。</p>
<p><strong>综合上述的分析，在使用Jedis的过程中需要合理设置参数包括connectionTimeout &amp; soTimeout &amp; maxAttempts。</strong></p>
<ul>
<li>maxAttempts：出现异常最大重试次数。</li>
<li>connectionTimeout：表示连接超时时间。</li>
<li>soTimeout：读取数据超时时间。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过线上故障现场记录和分析，并最终引申到Jedis源码的底层逻辑分析，剖析了Jedis的不合理参数设置包括连接超时和最大重试次数导致服务雪崩的整个过程。</p>
<p>在Redis本身只作为缓存且后端的MySQL等DB能够承载非高峰期流量的场景下，建议合理设置Jedis超时参数进而减少Redis主从切换访问Redis的耗时，避免服务雪崩。</p>
<p>线上环境笔者目前的连接和读取超时时间设置为100ms，最大重试次数为2，按照现有的业务逻辑如遇Redis节点故障访问异常最多耗时1s，能够有效避免服务发生雪崩。</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>问题排查</tag>
      </tags>
  </entry>
  <entry>
    <title>月光宝盒</title>
    <url>/posts/1794858777.html</url>
    <content><![CDATA[<p>月光宝盒是一个基于流量录制回放的自动化测试平台，通过录制回放取代编写脚本进行自动化回归，提升测试效率和覆盖率。因为其解决方案具有很强的通用性</p>
<h2 id="月光宝盒-是什么"><a href="#月光宝盒-是什么" class="headerlink" title="月光宝盒 是什么?"></a>月光宝盒 是什么?</h2><p>Moonbox（月光宝盒）是 <a href="https://github.com/alibaba/jvm-sandbox-repeater">JVM-Sandbox</a> 生态下的一款流量录制回放产品。所谓流量录制回放是服务端通过挂载agent探针自动注册到服务端，拦截服务端调用，将所有外部调用依赖的内容（如数据库、分布式缓存、外部服务响应等）进行完整记录形成录制流量。其核心价值是通过录制流量数据，将流量数据转化成可复用、可执行的自动化用例，快速在测试环境中进行回放比对接口返回值和外部调用依参数（见下图）。Moonbox（月光宝盒）提供了大量的常用插件，能够对常见的中间调用进行录制回放，同时也提供了非常可靠、高性能的数据存储、计算能力。</p>
<p> <img src="/../images/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E6%B5%81%E7%A8%8B.png" alt="测试环境流程"></p>
<h2 id="月光宝盒-有哪些优势？"><a href="#月光宝盒-有哪些优势？" class="headerlink" title="月光宝盒 有哪些优势？"></a>月光宝盒 有哪些优势？</h2><p>月光宝盒是一款面向测试、研发工程师使用的低门槛、高性能、更易于使用的自动化测试工具。这款产品已经在vivo运行了2年多了，经过我们持续优化、打磨拥有很多实用、易用功能。它的优点主要体现在下面几方面：</p>
<h3 id="全面可视化视操作（部分功能）"><a href="#全面可视化视操作（部分功能）" class="headerlink" title="全面可视化视操作（部分功能）"></a>全面可视化视操作（部分功能）</h3><p>(1）基于任务、接口维度的流量管理能力</p>
<p> <img src="/../images/%E6%9C%88%E5%85%89%E5%AE%9D%E7%9B%92%E5%90%8E%E5%8F%B01.png" alt="月光宝盒后台1"></p>
<p>(2）详细的流量展示细节（请求、响应、子调用）</p>
<p> <img src="/../images/%E6%9C%88%E5%85%89%E5%AE%9D%E7%9B%92%E5%90%8E%E5%8F%B02.png" alt="月光宝盒后台2"></p>
<p>(3）基于任务、接口维度的回放数据管理，叠加各种维度统计、查询能力</p>
<p> <img src="/../images/%E6%9C%88%E5%85%89%E5%AE%9D%E7%9B%92%E5%90%8E%E5%8F%B03.png" alt="月光宝盒后台3"></p>
<p>(4）易于人工分析的回放比对结果和差异展示</p>
<p> <img src="/../images/%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C%E5%AF%B9%E6%AF%94.png" alt="月光宝盒后台1"></p>
<h3 id="丰富的插件支持"><a href="#丰富的插件支持" class="headerlink" title="丰富的插件支持"></a>丰富的插件支持</h3><p>月光宝盒支持非常多组件录制和回放能力，基本上能满足绝大多数人诉求。</p>
<p> <img src="/../images/%E6%9C%88%E5%85%89%E5%AE%9D%E7%9B%92%E6%8F%92%E4%BB%B6.png" alt="月光宝盒插件"></p>
<h3 id="多种部署方式"><a href="#多种部署方式" class="headerlink" title="多种部署方式"></a>多种部署方式</h3><ul>
<li><strong>Docker：</strong>这种方式简单、可靠，让您可以摒弃复杂的环境配置和安装，快速在本地体验我们项目。</li>
<li><strong>常规方式：</strong>这种方式复杂、步骤繁琐，需要按照步骤创建ES和MySQL数据库，初始化数据表，更新好应用配置，安装好前端node服务。</li>
</ul>
<p>此外月光宝盒是前后端分离项目，当您使用该项目需要分别部署前端、后端，非常有助于您后续将项目部署到生产环境</p>
<h3 id="性能安全可靠"><a href="#性能安全可靠" class="headerlink" title="性能安全可靠"></a>性能安全可靠</h3><p>平台对性能进行了长期优化，在vivo内部历经多个高并发系统验证。我们对agent端录制流量进行了一系列安全防护，例如对相同接口同时只能有一个进入采样中，限制并行录制接口数量。服务端使用了ES储存流量，有效提升了数据储存规模。</p>
<h2 id="月光宝盒-实现原理"><a href="#月光宝盒-实现原理" class="headerlink" title="月光宝盒 实现原理"></a>月光宝盒 实现原理</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p>月光宝盒平台分为2个部分，分别为moonbox-agent 和 moonbox-server（整体架构如下图所示）</p>
<p><strong>moonbox-agent</strong></p>
<p>使用Java-attach技术(实际的动态字节码增强由JVM-Sandbox实现)动态代理到目标进程上，提供流量录制和回放的增强。</p>
<p><strong>moonbox-server</strong></p>
<ul>
<li>Agent端使用接口，提供配置查询、录制流量保存、流量查询、回放结果保存等服务</li>
<li>录制任务&#x2F;回放任务的配置，agent任务远程管理能力和管理后台操作界面(前后端分离部署)</li>
</ul>
<p><img src="/../images/%E6%9C%88%E5%85%89%E5%AE%9D%E7%9B%92%E6%9E%B6%E6%9E%84.png" alt="月光宝盒架构"></p>
<h3 id="流量录制-回放"><a href="#流量录制-回放" class="headerlink" title="流量录制&amp;回放"></a>流量录制&amp;回放</h3><p><strong>流量录制</strong></p>
<p>核心逻辑是将agent分发到用户填写的机器上(本地、远程机器），然后将agent attach到用户填写应用所对应的正确进程上去。然后通过JVM-Sandbox的BEFORE、RETRUN、THROW事件机制拦截关键调用位置获取流量入参、出参。整体流程见下图整体流程见下图：</p>
<p><img src="/../images/%E6%B5%81%E9%87%8F%E5%BD%95%E5%88%B6%E8%BF%87%E7%A8%8B.png" alt="流量录制过程"></p>
<p><strong>流量回放</strong></p>
<p>核心逻辑是将agent分发到用户填写的机器上(本地、远程机器），然后将agent attach到用户填写应用所对应的正确进程上去，agent启动后从服务端不断拉取流量去分发到对应接口做回放，整体流程见下图：</p>
<p><img src="/../images/%E6%B5%81%E9%87%8F%E5%9B%9E%E6%94%BE%E8%BF%87%E7%A8%8B.png" alt="流量回放过程"></p>
<p><strong>心跳管理</strong></p>
<p>Agent启动后会单独开启线程固定间隔时间通过http请求给服务端上报心跳</p>
<p><img src="/../images/%E5%BF%83%E8%B7%B3%E7%AE%A1%E7%90%86.png" alt="心跳管理"></p>
<h2 id="Agent启动过程"><a href="#Agent启动过程" class="headerlink" title="Agent启动过程"></a>Agent启动过程</h2><p>执行脚本将sandbox agent attach到目标java进程上，sandbox 启动jetty服务，加载moonbox module，然后从服务端拉取moonbox配置，加载流量录制和回放插件。</p>
<p><img src="/../images/Agent%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B.png" alt="Agent启动过程"></p>
<h2 id="和-jvm-sandbox-repeater-关系？"><a href="#和-jvm-sandbox-repeater-关系？" class="headerlink" title="和 jvm-sandbox-repeater 关系？"></a>和 jvm-sandbox-repeater 关系？</h2><p>Moonbox是基于jvm-sandbox-repeater重新开发的一款流量回放平台产品。在jvm-sandbox-repeater基础上重写了很多模块，并提供了更加丰富功能，同时便于线上部署和使用，和jvm-sandbox-repeater差异如下：</p>
<p><img src="/../images/%E5%B7%AE%E5%BC%82%E5%AF%B9%E6%AF%94.png" alt="差异对比"></p>
<h2 id="为什么要开源"><a href="#为什么要开源" class="headerlink" title="为什么要开源"></a>为什么要开源</h2><p>流量录制回放技术复杂，挑战较高，开源社区虽然有很多类似产品但是在易用性方面都有一些欠缺，我们希望通过开源月光宝盒帮助对该方向有兴趣的开发者快速构建自己的自动化工具，同时可以基于我们这款产品制定个性化诉求。此外，月光宝盒本身也借鉴了jvm-sandbox-repeater设计和方案，是开源的受益方，现在我们将自己思考和探索回馈给开源社区，丰富流量回放开源技术生态。除此之外通过社区中开发者的使用，也可以帮助我们更好的改进我们的工具，获得更多的需求场景输入，也能让该工具获得更加长远的发展。</p>
<h3 id="开源地址"><a href="#开源地址" class="headerlink" title="开源地址"></a>开源地址</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="TXT"><figure class="iseeu highlight /txt"><table><tr><td class="code"><pre><span class="line">GItHub项目地址：https://github.com/vivo/MoonBox</span><br></pre></td></tr></table></figure></div>



]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类加载器</title>
    <url>/posts/124460125.html</url>
    <content><![CDATA[<p>本文介绍类加载过程及如何自定义加载器。</p>
<h2 id="Java类加载器基本知识"><a href="#Java类加载器基本知识" class="headerlink" title="Java类加载器基本知识"></a>Java类加载器基本知识</h2><p>写好的代码经过编译变成了字节码，并且可以打包成 Jar 文件。然后 JVM 去加载需要的字节码，变成持久代&#x2F;元数据区上的 Class 对象，接着才会执行我们的程序逻辑。</p>
<p>运行 java 程序的第一步就是加载 class 文件&#x2F;或输入流里面包含的字节码。</p>
<h3 id="类的生命周期和加载过程"><a href="#类的生命周期和加载过程" class="headerlink" title="类的生命周期和加载过程"></a>类的生命周期和加载过程</h3><p><img src="/../images/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="类的生命周期"></p>
<p>一个类在 JVM 里的生命周期有 7 个阶段，分别是加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）、卸载（Unloading）。</p>
<p>其中前五个部分（加载，验证，准备，解析，初始化）统称为类加载，下面我们就分别来说一下这五个过程。</p>
<p>1）<strong>加载</strong> 加载阶段也可以称为“装载”阶段。 这个阶段主要的操作是： <strong>根据明确知道的 class 完全限定名, 来获取二进制 classfile 格式的字节流</strong>，简单点说就是找到文件系统中&#x2F;jar 包中&#x2F;或存在于任何地方的“<code>class 文件</code>”。 如果找不到二进制表示形式，则会抛出 <code>NoClassDefFound</code> 错误。</p>
<p>装载阶段并不会检查 classfile 的语法和格式。 类加载的整个过程主要由 JVM 和 Java 的类加载系统共同完成， 当然具体到 loading 阶段则是由 JVM 与具体的某一个类加载器（java.lang.classLoader）协作完成的。</p>
<p>2）<strong>校验</strong> 链接过程的第一个阶段是 <code>校验</code>，确保 class 文件里的字节流信息符合当前虚拟机的要求，不会危害虚拟机的安全。</p>
<p>校验过程检查 classfile 的语义，判断常量池中的符号，并执行类型检查， 主要目的是判断字节码的合法性，比如 magic number, 对版本号进行验证。 这些检查过程中可能会抛出 <code>VerifyError</code>， <code>ClassFormatError</code> 或 <code>UnsupportedClassVersionError</code>。</p>
<p>因为 classfile 的验证属是链接阶段的一部分，所以这个过程中可能需要加载其他类，在某个类的加载过程中，JVM 必须加载其所有的超类和接口。</p>
<p>如果类层次结构有问题（例如，该类是自己的超类或接口,死循环了），则 JVM 将抛出 <code>ClassCircularityError</code>。 而如果实现的接口并不是一个 interface，或者声明的超类是一个 interface，也会抛出 <code>IncompatibleClassChangeError</code>。</p>
<p>3）<strong>准备</strong></p>
<p>然后进入准备阶段，这个阶段将会创建静态字段, 并将其初始化为标准默认值(比如<code>null</code>或者<code>0 值</code>)，并分配方法表，即在方法区中分配这些变量所使用的内存空间。</p>
<p>请注意，<strong>准备阶段并未执行任何 Java 代码。</strong></p>
<p>例如：</p>
<blockquote>
<p>public static int i &#x3D; 1；</p>
</blockquote>
<p>在准备阶段<code>i</code>的值会被初始化为 0，后面在<strong>类初始化阶段才会执行赋值为 1</strong>；但是下面如果<strong>使用 final 作为静态常量</strong>，某些 JVM 的行为就不一样了：</p>
<blockquote>
<p><code>public static final int i = 1；</code> 对应常量 i，<strong>在准备阶段就会被赋值 1</strong>，其实这样还是比较 puzzle，例如其他语言（C#）有直接的常量关键字 const，让告诉编译器在编译阶段就替换成常量，类似于宏指令，更简单。</p>
</blockquote>
<p>4）<strong>解析</strong> 然后进入可选的解析符号引用阶段。 也就是解析常量池，主要有以下四种：类或接口的解析、字段解析、类方法解析、接口方法解析。</p>
<p>简单的来说就是我们编写的代码中，当一个变量引用某个对象的时候，这个引用在 <code>.class</code> 文件中是以符号引用来存储的（相当于做了一个索引记录）。</p>
<p>在解析阶段就需要将其解析并链接为直接引用（相当于指向实际对象）。如果有了直接引用，那引用的目标必定在堆中存在。</p>
<p>加载一个 class 时, 需要加载所有的 super 类和 super 接口。</p>
<p>5）<strong>初始化</strong> JVM 规范明确规定, 必须在类的首次“主动使用”时才能执行类初始化。</p>
<p>初始化的过程包括执行：</p>
<ul>
<li>类构造器方法</li>
<li>static 静态变量赋值语句</li>
<li>static 静态代码块</li>
</ul>
<p>如果是一个子类进行初始化会先对其父类进行初始化，保证其父类在子类之前进行初始化。所以其实在 java 中初始化一个类，那么必然先初始化过 <code>java.lang.Object</code> 类，因为所有的 java 类都继承自 java.lang.Object。</p>
<blockquote>
<p>只要我们尊重语言的语义，在执行下一步操作之前完成 装载，链接和初始化这些步骤，如果出错就按照规定抛出相应的错误，类加载系统完全可以根据自己的策略，灵活地进行符号解析等链接过程。 为了提高性能，HotSpot JVM 通常要等到类初始化时才去装载和链接类。 因此，如果 A 类引用了 B 类，那么加载 A 类并不一定会去加载 B 类（除非需要进行验证）。 主动对 B 类执行第一条指令时才会导致 B 类的初始化，这就需要先完成对 B 类的装载和链接。</p>
</blockquote>
<h3 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h3><p>了解了类的加载过程，我们再看看类的初始化何时会被触发呢？JVM 规范枚举了下述多种触发情况：</p>
<ul>
<li>当虚拟机启动时，初始化用户指定的主类，就是启动执行的 main 方法所在的类；</li>
<li>当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类，就是 new 一个类的时候要初始化；</li>
<li>当遇到调用静态方法的指令时，初始化该静态方法所在的类；</li>
<li>当遇到访问静态字段的指令时，初始化该静态字段所在的类；</li>
<li>子类的初始化会触发父类的初始化；</li>
<li>如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；</li>
<li>使用反射 API 对某个类进行反射调用时，初始化这个类，其实跟前面一样，反射调用要么是已经有实例了，要么是静态方法，都需要初始化；</li>
<li>当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。</li>
</ul>
<p>同时以下几种情况不会执行类初始化：</p>
<ul>
<li>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。</li>
<li>定义对象数组，不会触发该类的初始化。</li>
<li>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。</li>
<li>通过类名获取 Class 对象，不会触发类的初始化，Hello.class 不会让 Hello 类初始化。</li>
<li>通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。Class.forName(“jvm.Hello”)默认会加载 Hello 类。</li>
<li>通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作（加载了，但是不初始化）。</li>
</ul>
<p>示例: 诸如 Class.forName(), classLoader.loadClass() 等 Java API, 反射API, 以及 JNI_FindClass 都可以启动类加载。 JVM 本身也会进行类加载。 比如在 JVM 启动时加载核心类，java.lang.Object, java.lang.Thread 等等。</p>
<h3 id="类加载器机制"><a href="#类加载器机制" class="headerlink" title="类加载器机制"></a>类加载器机制</h3><p>类加载过程可以描述为“通过一个类的全限定名 a.b.c.XXClass 来获取描述此类的 Class 对象”，这个过程由“类加载器（ClassLoader）”来完成。这样的好处在于，子类加载器可以复用父加载器加载的类。系统自带的类加载器分为三种：</p>
<ul>
<li>启动类加载器（BootstrapClassLoader）</li>
<li>扩展类加载器（ExtClassLoader）</li>
<li>应用类加载器（AppClassLoader）</li>
</ul>
<p>一般启动类加载器是由 JVM 内部实现的，在 Java 的 API 里无法拿到，但是我们可以侧面看到和影响它（后面的内容会演示）。后 2 种类加载器在 Oracle Hotspot JVM 里，都是在中<code>sun.misc.Launcher</code>定义的，扩展类加载器和应用类加载器一般都继承自<code>URLClassLoader</code>类，这个类也默认实现了从各种不同来源加载 class 字节码转换成 Class 的方法。</p>
<p><img src="/../images/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.png" alt="类加载器"></p>
<ol>
<li>启动类加载器（bootstrap class loader）: 它用来加载 Java 的核心类，是用原生 C++ 代码来实现的，并不继承自 java.lang.ClassLoader（负责加载JDK中jre&#x2F;lib&#x2F;rt.jar里所有的class）。它可以看做是 JVM 自带的，我们再代码层面无法直接获取到启动类加载器的引用，所以不允许直接操作它， 如果打印出来就是个 <code>null</code>。举例来说，java.lang.String 是由启动类加载器加载的，所以 String.class.getClassLoader() 就会返回 null。但是后面可以看到可以通过命令行参数影响它加载什么。</li>
<li>扩展类加载器（extensions class loader）：它负责加载 JRE 的扩展目录，lib&#x2F;ext 或者由 java.ext.dirs 系统属性指定的目录中的 JAR 包的类，代码里直接获取它的父类加载器为 null（因为无法拿到启动类加载器）。</li>
<li>应用类加载器（app class loader）：它负责在 JVM 启动时加载来自 Java 命令的 -classpath 或者 -cp 选项、java.class.path 系统属性指定的 jar 包和类路径。在应用程序代码里可以通过 ClassLoader 的静态方法 getSystemClassLoader() 来获取应用类加载器。如果没有特别指定，则在没有使用自定义类加载器情况下，用户自定义的类都由此加载器加载。</li>
</ol>
<p>此外还可以自定义类加载器。如果用户自定义了类加载器，则自定义类加载器都以应用类加载器作为父加载器。应用类加载器的父类加载器为扩展类加载器。这些类加载器是有层次关系的，启动加载器又叫根加载器，是扩展加载器的父加载器，但是直接从 ExClassLoader 里拿不到它的引用，同样会返回 null。</p>
<p><img src="/../images/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="类加载器继承关系图"></p>
<p>类加载机制有三个特点：</p>
<ol>
<li>双亲委托：当一个自定义类加载器需要加载一个类，比如 java.lang.String，它很懒，不会一上来就直接试图加载它，而是先委托自己的父加载器去加载，父加载器如果发现自己还有父加载器，会一直往前找，这样只要上级加载器，比如启动类加载器已经加载了某个类比如 java.lang.String，所有的子加载器都不需要自己加载了。如果几个类加载器都没有加载到指定名称的类，那么会抛出 ClassNotFountException 异常。</li>
<li>负责依赖：如果一个加载器在加载某个类的时候，发现这个类依赖于另外几个类或接口，也会去尝试加载这些依赖项。</li>
<li>缓存加载：为了提升加载效率，消除重复加载，一旦某个类被一个类加载器加载，那么它会缓存这个加载结果，不会重复加载。</li>
</ol>
<h3 id="自定义类加载器示例"><a href="#自定义类加载器示例" class="headerlink" title="自定义类加载器示例"></a>自定义类加载器示例</h3><p>同时我们可以自行实现类加载器来加载其他格式的类，对加载方式、加载数据的格式进行自定义处理，只要能通过 classloader 返回一个 Class 实例即可。这就大大增强了加载器灵活性。比如我们试着实现一个可以用来处理简单加密的字节码的类加载器，用来保护我们的 class 字节码文件不被使用者直接拿来破解。</p>
<p>我们先来看看我们希望加载的一个 Hello 类：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello Class Initialized!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个 Hello 类非常简单，就是在自己被初始化的时候，打印出来一句“Hello Class Initialized!”。假设这个类的内容非常重要，我们不想把编译到得到的 Hello.class 给别人，但是我们还是想别人可以调用或执行这个类，应该怎么办呢？一个简单的思路是，我们把这个类的 class 文件二进制作为字节流先加密一下，然后尝试通过自定义的类加载器来加载加密后的数据。为了演示简单，我们使用 jdk 自带的 Base64 算法，把字节码加密成一个文本。在下面这个例子里，我们实现一个 HelloClassLoader，它继承自 ClassLoader 类，但是我们希望它通过我们提供的一段 Base64 字符串，来还原出来，并执行我们的 Hello 类里的打印一串字符串的逻辑。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HelloClassLoader</span>().findClass(<span class="string">&quot;jvm.Hello&quot;</span>).newInstance(); <span class="comment">// 加载并初始化Hello类</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">helloBase64</span> <span class="operator">=</span> <span class="string">&quot;yv66vgAAADQAHwoABgARCQASABMIABQKABUAFgcAFwcAGAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2N&quot;</span> +</span><br><span class="line">                <span class="string">&quot;hbFZhcmlhYmxlVGFibGUBAAR0aGlzAQALTGp2bS9IZWxsbzsBAAg8Y2xpbml0PgEAClNvdXJjZUZpbGUBAApIZWxsby5qYXZhDAAHAAgHABkMABoAGwEAGEhlb&quot;</span> +</span><br><span class="line">                <span class="string">&quot;GxvIENsYXNzIEluaXRpYWxpemVkIQcAHAwAHQAeAQAJanZtL0hlbGxvAQAQamF2YS9sYW5nL09iamVjdAEAEGphdmEvbGFuZy9TeXN0ZW0BAANvdXQBABVMamF2&quot;</span> +</span><br><span class="line">                <span class="string">&quot;YS9pby9QcmludFN0cmVhbTsBABNqYXZhL2lvL1ByaW50U3RyZWFtAQAHcHJpbnRsbgEAFShMamF2YS9sYW5nL1N0cmluZzspVgAhAAUABgAAAAAAAgABAAcACA&quot;</span> +</span><br><span class="line">                <span class="string">&quot;ABAAkAAAAvAAEAAQAAAAUqtwABsQAAAAIACgAAAAYAAQAAAAMACwAAAAwAAQAAAAUADAANAAAACAAOAAgAAQAJAAAAJQACAAAAAAAJsgACEgO2AASxAAAAAQAK&quot;</span> +</span><br><span class="line">                <span class="string">&quot;AAAACgACAAAABgAIAAcAAQAPAAAAAgAQ&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes = decode(helloBase64);</span><br><span class="line">        <span class="keyword">return</span> defineClass(name,bytes,<span class="number">0</span>,bytes.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] decode(String base64)&#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.getDecoder().decode(base64);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>直接执行这个类：</p>
<blockquote>
<p>$ java jvm.HelloClassLoader Hello Class Initialized!</p>
</blockquote>
<p>可以看到达到了我们的目的，成功执行了Hello类的代码，但是完全不需要有Hello这个类的class文件。此外，需要说明的是两个没有关系的自定义类加载器之间加载的类是不共享的（只共享父类加载器，兄弟之间不共享），这样就可以实现不同的类型沙箱的隔离性，我们可以用多个类加载器，各自加载同一个类的不同版本，大家可以相互之间不影响彼此，从而在这个基础上可以实现类的动态加载卸载，热插拔的插件机制等，具体信息大家可以参考OSGi等模块化技术。</p>
<h3 id="一些实用技巧"><a href="#一些实用技巧" class="headerlink" title="一些实用技巧"></a>一些实用技巧</h3><h4 id="1）如何排查找不到Jar包的问题？"><a href="#1）如何排查找不到Jar包的问题？" class="headerlink" title="1）如何排查找不到Jar包的问题？"></a>1）如何排查找不到Jar包的问题？</h4><p>有时候我们会面临明明已经把某个jar加入到了环境里，可以运行的时候还是找不到。那么我们有没有一种方法，可以直接看到各个类加载器加载了哪些jar，以及把哪些路径加到了classpath里？答案是肯定的，代码如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JvmClassLoaderPrintPath</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动类加载器</span></span><br><span class="line">        URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">        System.out.println(<span class="string">&quot;启动类加载器&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(URL url : urls) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; ==&gt; &quot;</span> +url.toExternalForm());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扩展类加载器</span></span><br><span class="line">        printClassLoader(<span class="string">&quot;扩展类加载器&quot;</span>, JvmClassLoaderPrintPath.class.getClassLoader().getParent());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 应用类加载器</span></span><br><span class="line">        printClassLoader(<span class="string">&quot;应用类加载器&quot;</span>, JvmClassLoaderPrintPath.class.getClassLoader());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printClassLoader</span><span class="params">(String name, ClassLoader CL)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(CL != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot; ClassLoader -&gt; &quot;</span> + CL.toString());</span><br><span class="line">            printURLForClassLoader(CL);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot; ClassLoader -&gt; null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printURLForClassLoader</span><span class="params">(ClassLoader CL)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">ucp</span> <span class="operator">=</span> insightField(CL,<span class="string">&quot;ucp&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">path</span> <span class="operator">=</span> insightField(ucp,<span class="string">&quot;path&quot;</span>);</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">ps</span> <span class="operator">=</span> (ArrayList) path;</span><br><span class="line">        <span class="keyword">for</span> (Object p : ps)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot; ==&gt; &quot;</span> + p.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">insightField</span><span class="params">(Object obj, String fName)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> URLClassLoader)&#123;</span><br><span class="line">                f = URLClassLoader.class.getDeclaredField(fName);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                f = obj.getClass().getDeclaredField(fName);</span><br><span class="line">            &#125;</span><br><span class="line">            f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> f.get(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>代码执行结果如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">启动类加载器</span><br><span class="line">   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/resources.jar</span><br><span class="line">   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/rt.jar</span><br><span class="line">   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/sunrsasign.jar</span><br><span class="line">   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/jsse.jar</span><br><span class="line">   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/jce.jar</span><br><span class="line">   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/charsets.jar</span><br><span class="line">   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/jfr.jar</span><br><span class="line">   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/classes</span><br><span class="line"></span><br><span class="line">扩展类加载器 ClassLoader -&gt; sun.misc.Launcher<span class="variable">$ExtClassLoader</span>@15db9742</span><br><span class="line">   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/access-bridge-64.jar</span><br><span class="line">   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/cldrdata.jar</span><br><span class="line">   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/dnsns.jar</span><br><span class="line">   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/jaccess.jar</span><br><span class="line">   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/jfxrt.jar</span><br><span class="line">   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/localedata.jar</span><br><span class="line">   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/nashorn.jar</span><br><span class="line">   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/sunec.jar</span><br><span class="line">   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/sunjce_provider.jar</span><br><span class="line">   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/sunmscapi.jar</span><br><span class="line">   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/sunpkcs11.jar</span><br><span class="line">   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/ext/zipfs.jar</span><br><span class="line"></span><br><span class="line">应用类加载器 ClassLoader -&gt; sun.misc.Launcher<span class="variable">$AppClassLoader</span>@73d16e93</span><br><span class="line">   ==&gt; file:/D:/git/studyjava/build/classes/java/main/</span><br><span class="line">   ==&gt; file:/D:/git/studyjava/build/resources/main</span><br></pre></td></tr></table></figure></div>

<p>从打印结果，我们可以看到三种类加载器各自默认加载了哪些 jar 包和包含了哪些 classpath 的路径。</p>
<h4 id="2）如何排查类的方法不一致的问题？"><a href="#2）如何排查类的方法不一致的问题？" class="headerlink" title="2）如何排查类的方法不一致的问题？"></a>2）如何排查类的方法不一致的问题？</h4><p>假如我们确定一个 jar 或者 class 已经在 classpath 里了，但是却总是提示<code>java.lang.NoSuchMethodError</code>，这是怎么回事呢？很可能是加载了错误的或者重复加载了不同版本的 jar 包。这时候，用前面的方法就可以先排查一下，<strong>加载了具体什么 jar，然后是不是不同路径下有重复的 class 文件，但是版本不一样</strong>。</p>
<h4 id="3）怎么看到加载了哪些类，以及加载顺序？"><a href="#3）怎么看到加载了哪些类，以及加载顺序？" class="headerlink" title="3）怎么看到加载了哪些类，以及加载顺序？"></a>3）怎么看到加载了哪些类，以及加载顺序？</h4><p>还是针对上一个问题，假如有两个地方有 Hello.class，一个是新版本，一个是旧的，怎么才能直观地看到他们的加载顺序呢？也没有问题，我们可以直接打印加载的类清单和加载顺序。</p>
<p>只需要在类的启动命令行参数加上<code>-XX:+TraceClassLoading</code> 或者 <code>-verbose</code> 即可，注意需要加载 Java 命令之后，要执行的类名之前，不然不起作用。例如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line">$ java -XX:+TraceClassLoading jvm.HelloClassLoader </span><br><span class="line">[<span class="meta">Opened D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]</span><br><span class="line">[<span class="meta">Loaded java.lang.Object from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]</span><br><span class="line">[<span class="meta">Loaded java.io.Serializable from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]</span><br><span class="line">[<span class="meta">Loaded java.lang.Comparable from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]</span><br><span class="line">[<span class="meta">Loaded java.lang.CharSequence from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]</span><br><span class="line">[<span class="meta">Loaded java.lang.String from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]</span><br><span class="line">[<span class="meta">Loaded java.lang.reflect.AnnotatedElement from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]</span><br><span class="line">[<span class="meta">Loaded java.lang.reflect.GenericDeclaration from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]</span><br><span class="line">[<span class="meta">Loaded java.lang.reflect.Type from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]</span><br><span class="line">[<span class="meta">Loaded java.lang.Class from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]</span><br><span class="line">[<span class="meta">Loaded java.lang.Cloneable from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]</span><br><span class="line">[<span class="meta">Loaded java.lang.ClassLoader from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]</span><br><span class="line">[<span class="meta">Loaded java.lang.System from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]</span><br><span class="line"><span class="comment">// .......  此处省略了100多条类加载信息</span></span><br><span class="line">[<span class="meta">Loaded jvm.Hello from __JVM_DefineClass__</span>]</span><br><span class="line">[<span class="meta">Loaded java.util.concurrent.ConcurrentHashMap$ForwardingNode from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]</span><br><span class="line">Hello Class Initialized!</span><br><span class="line">[<span class="meta">Loaded java.lang.Shutdown from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]</span><br><span class="line">[<span class="meta">Loaded java.lang.Shutdown$Lock from D:\Program Files\Java\jre1.8.0_231\lib\rt.jar</span>]</span><br></pre></td></tr></table></figure></div>

<p>上面的信息，可以很清楚的看到类的加载先后顺序，以及是从哪个 jar 里加载的，这样排查类加载的问题非常方便。</p>
<h4 id="4）怎么调整或修改-ext-和本地加载路径？"><a href="#4）怎么调整或修改-ext-和本地加载路径？" class="headerlink" title="4）怎么调整或修改 ext 和本地加载路径？"></a>4）怎么调整或修改 ext 和本地加载路径？</h4><p>从前面的例子我们可以看到，假如什么都不设置，直接执行 java 命令，默认也会加载非常多的 jar 包，怎么可以自定义加载哪些 jar 包呢？比如我的代码很简单，只加载 rt.jar 行不行？答案是肯定的。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">$ java -Dsun.boot.class.path=<span class="string">&quot;D:\Program Files\Java\jre1.8.0_231\lib\rt.jar&quot;</span> -Djava.ext.dirs= jvm.JvmClassLoaderPrintPath</span><br><span class="line"></span><br><span class="line">启动类加载器</span><br><span class="line">   ==&gt; file:/D:/Program%20Files/Java/jdk1.8.0_231/jre/lib/rt.jar</span><br><span class="line">扩展类加载器 ClassLoader -&gt; sun.misc.Launcher<span class="variable">$ExtClassLoader</span>@15db9742</span><br><span class="line">应用类加载器 ClassLoader -&gt; sun.misc.Launcher<span class="variable">$AppClassLoader</span>@73d16e93</span><br><span class="line">   ==&gt; file:/D:/git/studyjava/build/classes/java/main/</span><br><span class="line">   ==&gt; file:/D:/git/studyjava/build/resources/main</span><br></pre></td></tr></table></figure></div>

<p>我们看到启动类加载器只加载了 rt.jar，而扩展类加载器什么都没加载，这就达到了我们的目的。</p>
<p>其中命令行参数<code>-Dsun.boot.class.path</code>表示<strong>我们要指定启动类加载器加载什么</strong>，最基础的东西都在 rt.jar 这个包了里，所以一般配置它就够了。需要注意的是因为在 windows 系统默认 JDK 安装路径有个空格，所以需要把整个路径用双引号括起来，如果路径没有空格，或是 Linux&#x2F;Mac 系统，就不需要双引号了。</p>
<p><strong>参数<code>-Djava.ext.dirs</code>表示扩展类加载器要加载什么</strong>，一般情况下不需要的话可以直接配置为空即可。</p>
<h4 id="5）怎么运行期加载额外的-jar-包或者-class-呢？"><a href="#5）怎么运行期加载额外的-jar-包或者-class-呢？" class="headerlink" title="5）怎么运行期加载额外的 jar 包或者 class 呢？"></a>5）怎么运行期加载额外的 jar 包或者 class 呢？</h4><p>有时候我们在程序已经运行了以后，还是想要再额外的去加载一些 jar 或类，需要怎么做呢？</p>
<p>简单说就是不使用命令行参数的情况下，怎么用代码来运行时改变加载类的路径和方式。假如说，在<code>d:/app/jvm</code>路径下，有我们刚才使用过的 Hello.class 文件，怎么在代码里能加载这个 Hello 类呢？</p>
<p>两个办法，一个是前面提到的自定义 ClassLoader 的方式，还有一个就是直接在当前的应用类加载器里，使用 URLClassLoader 类的方法 addURL，不过这个方法是 protected 的，需要反射处理一下，然后又因为程序在启动时并没有显示加载 Hello 类，所以在添加完了 classpath 以后，没法直接显式初始化，需要使用 Class.forName 的方式来拿到已经加载的Hello类（Class.forName(“jvm.Hello”)默认会初始化并执行静态代码块）。代码如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JvmAppClassLoaderAddURL</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">appPath</span> <span class="operator">=</span> <span class="string">&quot;file:/d:/app/&quot;</span>;</span><br><span class="line">        <span class="type">URLClassLoader</span> <span class="variable">urlClassLoader</span> <span class="operator">=</span> (URLClassLoader) JvmAppClassLoaderAddURL.class.getClassLoader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">addURL</span> <span class="operator">=</span> URLClassLoader.class.getDeclaredMethod(<span class="string">&quot;addURL&quot;</span>, URL.class);</span><br><span class="line">            addURL.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(appPath);</span><br><span class="line">            addURL.invoke(urlClassLoader, url);</span><br><span class="line">            Class.forName(<span class="string">&quot;jvm.Hello&quot;</span>); <span class="comment">// 效果跟Class.forName(&quot;jvm.Hello&quot;).newInstance()一样</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>执行以下，结果如下：</p>
<blockquote>
<p>$ java JvmAppClassLoaderAddURL Hello Class Initialized!</p>
</blockquote>
<p>结果显示 Hello 类被加载，成功的初始化并执行了其中的代码逻辑。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM常见问题</title>
    <url>/posts/3273165295.html</url>
    <content><![CDATA[<p>本文讲述JVM相关的常见问题</p>
<h3 id="1-什么是-JVM？"><a href="#1-什么是-JVM？" class="headerlink" title="1. 什么是 JVM？"></a>1. 什么是 JVM？</h3><p>JVM 全称是 Java Virtual Machine，中文称为 Java 虚拟机。</p>
<p>JVM 是 Java 程序运行的底层平台，与 Java 支持库一起构成了 Java 程序的执行环境。</p>
<p>分为 JVM 规范和 JVM 实现两个部分。简单来说，Java 虚拟机就是指能执行标准 Java 字节码的虚拟计算机。</p>
<h4 id="1-1-请问-JDK-与-JVM-有什么区别？"><a href="#1-1-请问-JDK-与-JVM-有什么区别？" class="headerlink" title="1.1 请问 JDK 与 JVM 有什么区别？"></a><strong>1.1 请问 JDK 与 JVM 有什么区别？</strong></h4><p>现在的 JDK、JRE 和 JVM 一般是整套出现的。</p>
<ul>
<li>JDK &#x3D; JRE + 开发调试诊断工具</li>
<li>JRE &#x3D; JVM + Java 标准库</li>
</ul>
<h4 id="1-2-你认识哪些-JVM-厂商？"><a href="#1-2-你认识哪些-JVM-厂商？" class="headerlink" title="1.2 你认识哪些 JVM 厂商？"></a><strong>1.2 你认识哪些 JVM 厂商？</strong></h4><p>常见的 JDK 厂商包括：</p>
<ul>
<li>Oracle 公司，包括 Hotspot 虚拟机、GraalVM，分为 OpenJDK 和 OracleJDK 两种版本</li>
<li>IBM 公司，J9 虚拟机，用在 IBM 的产品套件中</li>
<li>Azul Systems 公司，高性能的 Zing 和开源的 Zulu</li>
<li>阿里巴巴，Dragonwell 是阿里开发的 OpenJDK 定制版</li>
<li>亚马逊，Corretto OpenJDK</li>
<li>Red Hat 公司的 OpenJDK</li>
<li>Adopt OpenJDK</li>
<li>此外，还有一些开源和试验性质的 JVM 实现，比如 Go.JVM</li>
</ul>
<h4 id="1-3-OracleJDK-与-OpenJDK-有什么区别？"><a href="#1-3-OracleJDK-与-OpenJDK-有什么区别？" class="headerlink" title="1.3 OracleJDK 与 OpenJDK 有什么区别？"></a><strong>1.3 OracleJDK 与 OpenJDK 有什么区别？</strong></h4><p>各种版本的 JDK 一般来说都会符合 Java 虚拟机规范。 两者的区别一般来说包括：</p>
<ul>
<li>两种 JDK 提供的工具套件略有差别，比如 jmc 等有版权的工具。</li>
<li>某些协议或配置不一样，比如美国限制出口的加密算法。</li>
<li>其他细微差别，比如 JRE 中某些私有的 API 不一样。</li>
</ul>
<h4 id="1-4-开发中使用哪个版本的-JDK？生产环境呢？为什么这么选？"><a href="#1-4-开发中使用哪个版本的-JDK？生产环境呢？为什么这么选？" class="headerlink" title="1.4 开发中使用哪个版本的 JDK？生产环境呢？为什么这么选？"></a><strong>1.4 开发中使用哪个版本的 JDK？生产环境呢？为什么这么选？</strong></h4><p>有一说一，选择哪个版本需要考虑研发团队的具体情况：比如机器的操作系统、团队成员的掌握情况、兼顾遗留项目等等。</p>
<p>当前 Java 最受欢迎的长期维护版本是 Java 8 和 Java 11。</p>
<ul>
<li>Java 8 是经典 LTS 版本，性能优秀，系统稳定，良好支持各种 CPU 架构和操作系统平台。</li>
<li>Java 11 是新的长期支持版，性能更强，支持更多新特性，而且经过几年的维护已经很稳定。</li>
</ul>
<p>有的企业在开发环境使用 OracleJDK，在生产环境使用 OpenJDK。也有的企业恰好相反，在开发环境使用 OpenJDK，在生产环境使用 OracleJDK。也有的公司使用同样的打包版本。开发和部署时只要进行过测试就没问题。一般来说，测试环境、预上线环境的 JDK 配置需要和生产环境一致。</p>
<h3 id="2-什么是-Java-字节码？"><a href="#2-什么是-Java-字节码？" class="headerlink" title="2. 什么是 Java 字节码？"></a>2. 什么是 Java 字节码？</h3><p>Java 中的字节码，是值 Java 源代码编译后的中间代码格式，一般称为字节码文件。</p>
<h4 id="2-1-字节码文件中包含哪些内容？"><a href="#2-1-字节码文件中包含哪些内容？" class="headerlink" title="2.1 字节码文件中包含哪些内容？"></a><strong>2.1 字节码文件中包含哪些内容？</strong></h4><p>字节码文件中，一般包含以下部分：</p>
<ul>
<li>版本号信息</li>
<li>静态常量池（符号常量）</li>
<li>类相关的信息</li>
<li>字段相关的信息</li>
<li>方法相关的信息</li>
<li>调试相关的信息</li>
</ul>
<p>可以说，大部分信息都是通过常量池中的符号常量来表述的。</p>
<h4 id="2-2-什么是常量？"><a href="#2-2-什么是常量？" class="headerlink" title="2.2 什么是常量？"></a><strong>2.2 什么是常量？</strong></h4><p>常量是指不变的量，字母 ‘K’ 或者数字 1024 在 UTF-8 编码中对应到对应的二进制格式都是不变的。同样地，字符串在 Java 中的二进制表示也是不变的, 比如 “KK”。</p>
<p>在 Java 中需要注意的是，final 关键字修饰的字段和变量，表示最终变量，只能赋值 1 次，不允许再次修改，由编译器和执行引擎共同保证。</p>
<h4 id="2-3-你怎么理解常量池？"><a href="#2-3-你怎么理解常量池？" class="headerlink" title="2.3 你怎么理解常量池？"></a><strong>2.3 你怎么理解常量池？</strong></h4><p>在 Java 中，常量池包括两层含义：</p>
<ul>
<li>静态常量池，class 文件中的一个部分，里面保存的是类相关的各种符号常量。</li>
<li>运行时常量池，其内容主要由静态常量池解析得到，但也可以由程序添加。</li>
</ul>
<h3 id="3-JVM-的运行时数据区有哪些？"><a href="#3-JVM-的运行时数据区有哪些？" class="headerlink" title="3. JVM 的运行时数据区有哪些？"></a>3. JVM 的运行时数据区有哪些？</h3><p>根据 <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-2.html#jvms-2.5">JVM 规范</a>，标准的 JVM 运行时数据区包括以下部分：</p>
<ul>
<li>程序计数器</li>
<li>Java 虚拟机栈</li>
<li>堆内存</li>
<li>方法区</li>
<li>运行时常量池</li>
<li>本地方法栈</li>
</ul>
<p>具体的 JVM 实现可根据实际情况进行优化或者合并，满足规范的要求即可。</p>
<h4 id="3-1-什么是堆内存？"><a href="#3-1-什么是堆内存？" class="headerlink" title="3.1 什么是堆内存？"></a><strong>3.1 什么是堆内存？</strong></h4><p>堆内存是指由程序代码自由分配的内存，与栈内存作区分。</p>
<p>在 Java 中，堆内存主要用于分配对象的存储空间，只要拿到对象引用，所有线程都可以访问堆内存。</p>
<h4 id="3-2-堆内存包括哪些部分？"><a href="#3-2-堆内存包括哪些部分？" class="headerlink" title="3.2 堆内存包括哪些部分？"></a><strong>3.2 堆内存包括哪些部分？</strong></h4><p>以 Hotspot 为例，堆内存（HEAP）主要由 GC 模块进行分配和管理，可分为以下部分：</p>
<ul>
<li>新生代</li>
<li>存活区</li>
<li>老年代</li>
</ul>
<p>其中，新生代和存活区一般称为年轻代。</p>
<h4 id="3-3-什么是非堆内存？"><a href="#3-3-什么是非堆内存？" class="headerlink" title="3.3 什么是非堆内存？"></a><strong>3.3 什么是非堆内存？</strong></h4><p>除堆内存之外，JVM 的内存池还包括非堆（NON_HEAP），对应于 JVM 规范中的方法区，常量池等部分：</p>
<ul>
<li>MetaSpace</li>
<li>CodeCache</li>
<li>Compressed Class Space</li>
</ul>
<h3 id="4-什么是内存溢出？"><a href="#4-什么是内存溢出？" class="headerlink" title="4. 什么是内存溢出？"></a>4. 什么是内存溢出？</h3><p>内存溢出（OOM）是指可用内存不足。</p>
<p>程序运行需要使用的内存超出最大可用值，如果不进行处理就会影响到其他进程，所以现在操作系统的处理办法是：只要超出立即报错，比如抛出“内存溢出错误”。</p>
<p>就像杯子装不下，满了要溢出来一样，比如一个杯子只有 500ml 的容量，却倒进去 600ml，于是水就溢出造成破坏。</p>
<h4 id="4-1-什么是内存泄漏？"><a href="#4-1-什么是内存泄漏？" class="headerlink" title="4.1 什么是内存泄漏？"></a><strong>4.1 什么是内存泄漏？</strong></h4><p>内存泄漏（Memory Leak）是指本来无用的对象却继续占用内存，没有再恰当的时机释放占用的内存。</p>
<p>不使用的内存，却没有被释放，称为“内存泄漏”。也就是该释放的没释放，该回收的没回收。</p>
<p>比较典型的场景是：每一个请求进来，或者每一次操作处理，都分配了内存，却有一部分不能回收（或未释放），那么随着处理的请求越来越多，内存泄漏也就越来越严重。</p>
<p>在 Java 中一般是指无用的对象却因为错误的引用关系，不能被 GC 回收清理。</p>
<h4 id="4-2-两者有什么关系？"><a href="#4-2-两者有什么关系？" class="headerlink" title="4.2 两者有什么关系？"></a><strong>4.2 两者有什么关系？</strong></h4><p>如果存在严重的内存泄漏问题，随着时间的推移，则必然会引起内存溢出。</p>
<p>内存泄漏一般是资源管理问题和程序 Bug，内存溢出则是内存空间不足和内存泄漏的最终结果。</p>
<h3 id="5-给定一个具体的类，请分析对象的内存占用"><a href="#5-给定一个具体的类，请分析对象的内存占用" class="headerlink" title="5. 给定一个具体的类，请分析对象的内存占用"></a>5. 给定一个具体的类，请分析对象的内存占用</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyOrder</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">long</span> orderId;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">long</span> userId;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">byte</span> state;</span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">long</span> createMillis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>一般来说，MyOrder 类的每个对象会占用 40 个字节。</p>
<h4 id="5-1-怎么计算出来的？"><a href="#5-1-怎么计算出来的？" class="headerlink" title="5.1 怎么计算出来的？"></a><strong>5.1 怎么计算出来的？</strong></h4><p>计算方式为：</p>
<ul>
<li>对象头占用 12 字节。</li>
<li>每个 long 类型的字段占用 8 字节，3 个 long 字段占用 24 字节。</li>
<li>byte 字段占用 1 个字节。</li>
<li>以上合计 37 字节，加上以 8 字节对齐，则实际占用 40 个字节。</li>
</ul>
<h4 id="5-2-对象头中包含哪些部分？"><a href="#5-2-对象头中包含哪些部分？" class="headerlink" title="5.2 对象头中包含哪些部分？"></a><strong>5.2 对象头中包含哪些部分？</strong></h4><p>对象头中一般包含两个部分：</p>
<ul>
<li>标记字，占用一个机器字，也就是 8 字节。</li>
<li>类型指针，占用一个机器字，也就是 8 个字节。</li>
<li>如果堆内存小于 32GB，JVM 默认会开启指针压缩，则只占用 4 个字节。</li>
</ul>
<p>所以前面的计算中，对象头占用 12 字节。如果是数组，对象头中还会多出一个部分：</p>
<ul>
<li>数组长度，int 值，占用 4 字节。</li>
</ul>
<h3 id="6-常用的-JVM-启动参数有哪些？"><a href="#6-常用的-JVM-启动参数有哪些？" class="headerlink" title="6. 常用的 JVM 启动参数有哪些？"></a>6. 常用的 JVM 启动参数有哪些？</h3><p>截止目前（2020 年 3 月），JVM 可配置参数已经达到 1000 多个，其中 GC 和内存配置相关的 JVM 参数就有 600 多个。但在绝大部分业务场景下，常用的 JVM 配置参数也就 10 来个。</p>
<p>例如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">JVM 启动参数不换行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置堆内存</span></span><br><span class="line">-Xmx4g -Xms4g </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定 GC 算法</span></span><br><span class="line">-XX:+UseG1GC -XX:MaxGCPauseMillis=50 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定 GC 并行线程数</span></span><br><span class="line">-XX:ParallelGCThreads=4 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印 GC 日志</span></span><br><span class="line">-XX:+PrintGCDetails -XX:+PrintGCDateStamps </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定 GC 日志文件</span></span><br><span class="line">-Xloggc:gc.log </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定 Meta 区的最大值</span></span><br><span class="line">-XX:MaxMetaspaceSize=2g </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置单个线程栈的大小</span></span><br><span class="line">-Xss1m </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定堆内存溢出时自动进行 Dump</span></span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError </span><br><span class="line">-XX:HeapDumpPath=/usr/local/</span><br></pre></td></tr></table></figure></div>

<p>此外，还有一些常用的属性配置：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="INI"><figure class="iseeu highlight /ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定默认的连接超时时间</span></span><br><span class="line"><span class="attr">-Dsun.net.client.defaultConnectTimeout</span>=<span class="number">2000</span></span><br><span class="line"><span class="attr">-Dsun.net.client.defaultReadTimeout</span>=<span class="number">2000</span></span><br><span class="line"><span class="comment"># 指定时区</span></span><br><span class="line"><span class="attr">-Duser.timezone</span>=GMT+<span class="number">08</span> </span><br><span class="line"><span class="comment"># 设置默认的文件编码为 UTF-8</span></span><br><span class="line"><span class="attr">-Dfile.encoding</span>=UTF-<span class="number">8</span> </span><br><span class="line"><span class="comment"># 指定随机数熵源(Entropy Source)</span></span><br><span class="line"><span class="attr">-Djava.security.egd</span>=file:/dev/./urandom </span><br></pre></td></tr></table></figure></div>

<h4 id="6-1-设置堆内存-XMX-应该考虑哪些因素？"><a href="#6-1-设置堆内存-XMX-应该考虑哪些因素？" class="headerlink" title="6.1 设置堆内存 XMX 应该考虑哪些因素？"></a><strong>6.1 设置堆内存 XMX 应该考虑哪些因素？</strong></h4><p>需要根据系统的配置来确定，要给操作系统和 JVM 本身留下一定的剩余空间。推荐配置系统或容器里可用内存的 70~80% 最好。</p>
<h4 id="6-2-假设物理内存是-8G，设置多大堆内存比较合适？"><a href="#6-2-假设物理内存是-8G，设置多大堆内存比较合适？" class="headerlink" title="6.2 假设物理内存是 8G，设置多大堆内存比较合适？"></a><strong>6.2 假设物理内存是 8G，设置多大堆内存比较合适？</strong></h4><p>比如说系统有 8G 物理内存，系统自己可能会用掉一点，大概还有 7.5G 可以用，那么建议配置 <code>-Xmx6g</code>。</p>
<p>说明：7.5G*0.8&#x3D;6G，如果知道系统里有明确使用堆外内存的地方，还需要进一步降低这个值。</p>
<h4 id="6-3-Xmx-设置的值与-JVM-进程所占用的内存有什么关系？"><a href="#6-3-Xmx-设置的值与-JVM-进程所占用的内存有什么关系？" class="headerlink" title="6.3 -Xmx 设置的值与 JVM 进程所占用的内存有什么关系？"></a><strong>6.3 -Xmx 设置的值与 JVM 进程所占用的内存有什么关系？</strong></h4><p>JVM 总内存 &#x3D; 栈 + 堆 + 非堆 + 堆外 + Native</p>
<h4 id="6-4-怎样开启-GC-日志？"><a href="#6-4-怎样开启-GC-日志？" class="headerlink" title="6.4 怎样开启 GC 日志？"></a><strong>6.4 怎样开启 GC 日志？</strong></h4><p>一般来说，JDK 8 及以下版本通过以下参数来开启 GC 日志：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="RUBY"><figure class="iseeu highlight /ruby"><table><tr><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+PrintGCDetails</span> -<span class="variable constant_">XX</span><span class="symbol">:+PrintGCDateStamps</span> -<span class="title class_">Xloggc</span><span class="symbol">:gc</span>.log</span><br></pre></td></tr></table></figure></div>

<p>如果是在 JDK 9 及以上的版本，则格式略有不同：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LUA"><figure class="iseeu highlight /lua"><table><tr><td class="code"><pre><span class="line">-Xlog:gc*=info:file=gc.<span class="built_in">log</span>:<span class="built_in">time</span>:filecount=<span class="number">0</span></span><br></pre></td></tr></table></figure></div>

<h4 id="6-5-请指定使用-G1-垃圾收集器来启动-Hello-程序"><a href="#6-5-请指定使用-G1-垃圾收集器来启动-Hello-程序" class="headerlink" title="6.5 请指定使用 G1 垃圾收集器来启动 Hello 程序"></a><strong>6.5 请指定使用 G1 垃圾收集器来启动 Hello 程序</strong></h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="RUBY"><figure class="iseeu highlight /ruby"><table><tr><td class="code"><pre><span class="line">java -<span class="variable constant_">XX</span><span class="symbol">:+UseG1GC</span></span><br><span class="line">-<span class="title class_">Xms4g</span></span><br><span class="line">-<span class="title class_">Xmx4g</span></span><br><span class="line">-<span class="title class_">Xloggc</span><span class="symbol">:gc</span>.log</span><br><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+PrintGCDetails</span></span><br><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+PrintGCDateStamps</span></span><br><span class="line"><span class="title class_">Hello</span></span><br></pre></td></tr></table></figure></div>

<h3 id="7-Java-8-默认使用的垃圾收集器是什么？"><a href="#7-Java-8-默认使用的垃圾收集器是什么？" class="headerlink" title="7. Java 8 默认使用的垃圾收集器是什么？"></a>7. Java 8 默认使用的垃圾收集器是什么？</h3><p>Java 8 版本的 Hotspot JVM，默认情况下使用的是并行垃圾收集器（Parallel GC）。其他厂商提供的 JDK 8 基本上也默认使用并行垃圾收集器。</p>
<h4 id="7-1-Java11-的默认垃圾收集器是什么？"><a href="#7-1-Java11-的默认垃圾收集器是什么？" class="headerlink" title="7.1 Java11 的默认垃圾收集器是什么？"></a><strong>7.1 Java11 的默认垃圾收集器是什么？</strong></h4><p>Java 9 之后，官方 JDK 默认使用的垃圾收集器是 G1。</p>
<h4 id="7-2-常见的垃圾收集器有哪些？"><a href="#7-2-常见的垃圾收集器有哪些？" class="headerlink" title="7.2 常见的垃圾收集器有哪些？"></a><strong>7.2 常见的垃圾收集器有哪些？</strong></h4><p>常见的垃圾收集器包括：</p>
<ul>
<li>串行垃圾收集器：<code>-XX:+UseSerialGC</code></li>
<li>并行垃圾收集器：<code>-XX:+UseParallelGC</code></li>
<li>CMS 垃圾收集器：<code>-XX:+UseConcMarkSweepGC</code></li>
<li>G1 垃圾收集器：<code>-XX:+UseG1GC</code></li>
</ul>
<h4 id="7-3-什么是串行垃圾收集？"><a href="#7-3-什么是串行垃圾收集？" class="headerlink" title="7.3 什么是串行垃圾收集？"></a><strong>7.3 什么是串行垃圾收集？</strong></h4><p>就是只有单个 worker 线程来执行 GC 工作。</p>
<h4 id="7-4-什么是并行垃圾收集？"><a href="#7-4-什么是并行垃圾收集？" class="headerlink" title="7.4 什么是并行垃圾收集？"></a><strong>7.4 什么是并行垃圾收集？</strong></h4><p>并行垃圾收集，是指使用多个 GC worker 线程并行地执行垃圾收集，能充分利用多核 CPU 的能力，缩短垃圾收集的暂停时间。</p>
<p>除了单线程的 GC，其他的垃圾收集器，比如 PS、CMS、G1 等新的垃圾收集器都使用了多个线程来并行执行 GC 工作。</p>
<h4 id="7-5-什么是并发垃圾收集器？"><a href="#7-5-什么是并发垃圾收集器？" class="headerlink" title="7.5 什么是并发垃圾收集器？"></a><strong>7.5 什么是并发垃圾收集器？</strong></h4><p>并发垃圾收集器，是指在应用程序在正常执行时，有一部分 GC 任务，由 GC 线程在应用线程一起并发执行。 例如 CMS&#x2F;G1 的各种并发阶段。</p>
<h4 id="7-6-什么是增量式垃圾收集？"><a href="#7-6-什么是增量式垃圾收集？" class="headerlink" title="7.6 什么是增量式垃圾收集？"></a><strong>7.6 什么是增量式垃圾收集？</strong></h4><p>首先，G1 的堆内存不再单纯划分为年轻代和老年代，而是划分为多个（通常是 2048 个）可以存放对象的小块堆区域（smaller heap regions）。</p>
<p>每个小块，可能一会被定义成 Eden 区，一会被指定为 Survivor 区或者 Old 区。</p>
<p>这样划分之后，使得 G1 不必每次都去回收整个堆空间，而是以增量的方式来进行处理：每次只处理一部分内存块，称为此次 GC 的回收集（collection set）。</p>
<p>下一次 GC 时在本次的基础上，再选定一定的区域来进行回收。增量式垃圾收集的好处是大大降低了单次 GC 暂停的时间。</p>
<h4 id="7-7-什么是年轻代？"><a href="#7-7-什么是年轻代？" class="headerlink" title="7.7 什么是年轻代？"></a><strong>7.7 什么是年轻代？</strong></h4><p>年轻代是分来垃圾收集算法中的一个概念，相对于老年代而言，年轻代一般包括：</p>
<ul>
<li>新生代，Eden 区。</li>
<li>存活区，执行年轻代 GC 时，用存活区来保存活下来的对象。存活区也是年轻代的一部分，但一般有 2 个存活区，所以可以来回倒腾。</li>
</ul>
<h4 id="7-8-什么是-GC-停顿（GC-pause）？"><a href="#7-8-什么是-GC-停顿（GC-pause）？" class="headerlink" title="7.8 什么是 GC 停顿（GC pause）？"></a><strong>7.8 什么是 GC 停顿（GC pause）？</strong></h4><p>因为 GC 过程中，有一部分操作需要等所有应用线程都到达安全点，暂停之后才能执行，这时候就叫做 GC 停顿，或者叫做 GC 暂停。</p>
<h4 id="7-9-GC-停顿与-STW-停顿有什么区别？"><a href="#7-9-GC-停顿与-STW-停顿有什么区别？" class="headerlink" title="7.9 GC 停顿与 STW 停顿有什么区别？"></a><strong>7.9 GC 停顿与 STW 停顿有什么区别？</strong></h4><p>这两者一般可以认为就是同一个意思。</p>
<h3 id="8-如果-CPU-使用率突然飙升，你会怎么排查？"><a href="#8-如果-CPU-使用率突然飙升，你会怎么排查？" class="headerlink" title="8. 如果 CPU 使用率突然飙升，你会怎么排查？"></a>8. 如果 CPU 使用率突然飙升，你会怎么排查？</h3><p>缺乏经验的话，针对当前问题，往往需要使用不同的工具来收集信息，例如：</p>
<ul>
<li>收集不同的指标（CPU、内存、磁盘 IO、网络等等）</li>
<li>分析应用日志</li>
<li>分析 GC 日志</li>
<li>获取线程转储并分析</li>
<li>获取堆转储来进行分析</li>
</ul>
<h4 id="8-1-如果系统响应变慢，你会怎么排查？"><a href="#8-1-如果系统响应变慢，你会怎么排查？" class="headerlink" title="8.1 如果系统响应变慢，你会怎么排查？"></a><strong>8.1 如果系统响应变慢，你会怎么排查？</strong></h4><p>一般根据 APM 监控来排查应用系统本身的问题，有时候也可以使用 Chrome 浏览器等工具来排查外部原因，比如网络问题。</p>
<h4 id="8-2-系统性能一般怎么衡量？"><a href="#8-2-系统性能一般怎么衡量？" class="headerlink" title="8.2 系统性能一般怎么衡量？"></a><strong>8.2 系统性能一般怎么衡量？</strong></h4><p>可量化的 3 个性能指标：</p>
<ul>
<li>系统容量：比如硬件配置，设计容量；</li>
<li>吞吐量：最直观的指标是 TPS；</li>
<li>响应时间：也就是系统延迟，包括服务端延时和网络延迟。</li>
</ul>
<p>这些指标。可以具体拓展到单机并发、总体并发、数据量、用户数、预算成本等等。</p>
<h3 id="9-使用过哪些-JVM-相关的工具？"><a href="#9-使用过哪些-JVM-相关的工具？" class="headerlink" title="9. 使用过哪些 JVM 相关的工具？"></a>9. 使用过哪些 JVM 相关的工具？</h3><p>这个问题请根据实际情况回答，比如 Linux 命令，或者 JDK 提供的工具等。</p>
<h4 id="9-1-查看-JVM-进程号的命令是什么？"><a href="#9-1-查看-JVM-进程号的命令是什么？" class="headerlink" title="9.1 查看 JVM 进程号的命令是什么？"></a><strong>9.1 查看 JVM 进程号的命令是什么？</strong></h4><p>可以使用 <code>ps -ef</code> 和 <code>jps -v</code> 等等。</p>
<h4 id="9-2-怎么查看剩余内存？"><a href="#9-2-怎么查看剩余内存？" class="headerlink" title="9.2 怎么查看剩余内存？"></a><strong>9.2 怎么查看剩余内存？</strong></h4><p>比如：<code>free -m</code>、<code>free -h</code>、<code>top</code> 命令等等。</p>
<h4 id="9-3-查看线程栈的工具是什么？"><a href="#9-3-查看线程栈的工具是什么？" class="headerlink" title="9.3 查看线程栈的工具是什么？"></a><strong>9.3 查看线程栈的工具是什么？</strong></h4><p>一般先使用 jps 命令，再使用 <code>jstack -l</code>。</p>
<h4 id="9-4-用什么工具来获取堆内存转储？"><a href="#9-4-用什么工具来获取堆内存转储？" class="headerlink" title="9.4 用什么工具来获取堆内存转储？"></a><strong>9.4 用什么工具来获取堆内存转储？</strong></h4><p>一般使用 jmap 工具来获取堆内存快照。</p>
<h4 id="9-5-内存-Dump-时有哪些注意事项？"><a href="#9-5-内存-Dump-时有哪些注意事项？" class="headerlink" title="9.5 内存 Dump 时有哪些注意事项？"></a><strong>9.5 内存 Dump 时有哪些注意事项？</strong></h4><p>根据实际情况来看，获取内存快照可能会让系统暂停或阻塞一段时间，根据内存量决定。</p>
<p>使用 jmap 时，如果指定 live 参数，则会触发一次 Full GC，需要注意。</p>
<h4 id="9-6-使用-JMAP-转储堆内存大致的参数怎么处理？"><a href="#9-6-使用-JMAP-转储堆内存大致的参数怎么处理？" class="headerlink" title="9.6 使用 JMAP 转储堆内存大致的参数怎么处理？"></a><strong>9.6 使用 JMAP 转储堆内存大致的参数怎么处理？</strong></h4><p>示例：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="LUA"><figure class="iseeu highlight /lua"><table><tr><td class="code"><pre><span class="line">jmap -<span class="built_in">dump</span>:<span class="built_in">format</span>=b,file=<span class="number">3826.</span>hprof <span class="number">3826</span></span><br></pre></td></tr></table></figure></div>

<h4 id="9-7-为什么转储文件以-hprof-结尾？"><a href="#9-7-为什么转储文件以-hprof-结尾？" class="headerlink" title="9.7 为什么转储文件以 .hprof 结尾？"></a><strong>9.7 为什么转储文件以 .hprof 结尾？</strong></h4><p>JVM 有一个内置的分析器叫做 HPROF，堆内存转储文件的格式，最早就是这款工具定义的。</p>
<h4 id="9-8-内存-Dump-完成之后，用什么工具来分析？"><a href="#9-8-内存-Dump-完成之后，用什么工具来分析？" class="headerlink" title="9.8 内存 Dump 完成之后，用什么工具来分析？"></a><strong>9.8 内存 Dump 完成之后，用什么工具来分析？</strong></h4><p>一般使用 Eclipse MAT 工具，或者 jhat 工具来处理。</p>
<h4 id="9-9-如果忘记了使用什么参数你一般怎么处理？"><a href="#9-9-如果忘记了使用什么参数你一般怎么处理？" class="headerlink" title="9.9 如果忘记了使用什么参数你一般怎么处理？"></a><strong>9.9 如果忘记了使用什么参数你一般怎么处理？</strong></h4><p>上网搜索是比较笨的办法，但也是一种办法。</p>
<p>另外就是，各种 JDK 工具都支持 <code>-h</code> 选项来查看帮助信息，只要用得比较熟练，即使忘记了也很容易根据提示进行操作。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>常见GC算法</title>
    <url>/posts/578831626.html</url>
    <content><![CDATA[<p>大多数 JVM 都需要使用两种不同的 GC 算法——一种用来清理年轻代，另一种用来清理老年代。</p>
<p>我们可以选择 JVM 内置的各种算法。如果不通过参数明确指定垃圾收集算法，则会使用相应 JDK 版本的默认实现。</p>
<h2 id="常见垃圾收集器"><a href="#常见垃圾收集器" class="headerlink" title="常见垃圾收集器"></a>常见垃圾收集器</h2><h3 id="串行-GC（Serial-GC）"><a href="#串行-GC（Serial-GC）" class="headerlink" title="串行 GC（Serial GC）"></a>串行 GC（Serial GC）</h3><p>串行 GC 对年轻代使用 mark-copy（标记—复制）算法，对老年代使用 mark-sweep-compact（标记—清除—整理）算法。</p>
<p>两者都是单线程的垃圾收集器，不能进行并行处理，所以都会触发全线暂停（STW），停止所有的应用线程。</p>
<p>要启用此款收集器，只需要指定一个 JVM 启动参数即可，同时对年轻代和老年代生效：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="RUBY"><figure class="iseeu highlight /ruby"><table><tr><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+UseSerialGC</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>该选项只适合几百 MB 堆内存的 JVM，而且是单核 CPU 时比较有用</p>
</blockquote>
<h3 id="并行-GC（Parallel-GC）"><a href="#并行-GC（Parallel-GC）" class="headerlink" title="并行 GC（Parallel GC）"></a>并行 GC（Parallel GC）</h3><p>并行垃圾收集器这一类组合，在<strong>年轻代使用“标记—复制（mark-copy）算法”</strong>，在<strong>老年代使用“标记—清除—整理（mark-sweep-compact）算法”</strong>。年轻代和老年代的垃圾回收都会触发 STW 事件，暂停所有的应用线程来执行垃圾收集。两者在执行“标记和复制&#x2F;整理”阶段时都使用多个线程，因此得名“<strong>Parallel</strong>”。通过并行执行，使得 GC 时间大幅减少。</p>
<p>通过命令行参数 <code>-XX:ParallelGCThreads=NNN</code> 来指定 GC 线程数，其默认值为 CPU 核心数。可以通过下面的任意一组命令行参数来指定并行 GC：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="RUBY"><figure class="iseeu highlight /ruby"><table><tr><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+UseParallelGC</span></span><br><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+UseParallelOldGC</span></span><br><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+UseParallelGC</span> -<span class="variable constant_">XX</span><span class="symbol">:+UseParallelOldGC</span></span><br></pre></td></tr></table></figure></div>

<p>并行垃圾收集器适用于多核服务器，主要目标是增加吞吐量。因为对系统资源的有效使用，能达到更高的吞吐量：</p>
<ul>
<li>在 GC 期间，所有 CPU 内核都在并行清理垃圾，所以总暂停时间更短；</li>
<li>在两次 GC 周期的间隔期，没有 GC 线程在运行，不会消耗任何系统资源。</li>
</ul>
<p>另一方面，因为此 GC 的所有阶段都不能中断，所以并行 GC 很容易出现长时间的卡顿（注：这里说的长时间也很短，一般来说例如 minor GC 是毫秒级别，full GC 是几十几百毫秒级别）。</p>
<blockquote>
<p>如果系统的主要<strong>目标是最低的停顿时间&#x2F;延迟</strong>，而不是整体的吞吐量最大，那么就应该选择其他垃圾收集器组合。</p>
</blockquote>
<blockquote>
<p><strong>注</strong>：长时间卡顿的意思是，此 GC 启动之后，属于一次性完成所有操作，于是单次 暂停 的时间会较长。</p>
</blockquote>
<h3 id="CMS-垃圾收集器"><a href="#CMS-垃圾收集器" class="headerlink" title="CMS 垃圾收集器"></a>CMS 垃圾收集器</h3><p>CMS GC 的官方名称为 <strong>Mostly Concurrent Mark and Sweep Garbage Collector</strong>（最大并发—标记—清除—垃圾收集器）。其<strong>对年轻代采用并行 STW 方式的 mark-copy（标记—复制）算法</strong>，对<strong>老年代主要使用并发 mark-sweep（标记—清除）算法</strong>。</p>
<p>CMS GC 的设计目标是避免在老年代垃圾收集时出现长时间的卡顿，主要通过两种手段来达成此目标：</p>
<ul>
<li>第一，不对老年代进行整理，而是使用空闲列表（free-lists）来管理内存空间的回收。</li>
<li>第二，在 <strong>mark-and-sweep</strong>（标记—清除）阶段的大部分工作和应用线程一起并发执行。</li>
</ul>
<p>也就是说，在这些阶段并没有明显的应用线程暂停。但值得注意的是，它仍然和应用线程争抢 CPU 时间。默认情况下，CMS 使用的并发线程数等于 CPU 核心数的 1&#x2F;4。</p>
<p>通过以下选项来指定 CMS 垃圾收集器：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="RUBY"><figure class="iseeu highlight /ruby"><table><tr><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+UseConcMarkSweepGC</span></span><br></pre></td></tr></table></figure></div>

<p>如果服务器是多核 CPU，并且主要<strong>调优目标是降低 GC 停顿导致的系统延迟，那么使用 CMS 是个很明智的选择</strong>。通过减少每一次 GC 停顿的时间，很多时候会直接改善系统的用户体验。因为多数时候都有部分 CPU 资源被 GC 消耗，所以<strong>在 CPU 资源受限的情况下，CMS GC 会比并行 GC 的吞吐量差一些</strong>（对于绝大部分系统，这个吞吐和延迟的差别应该都不明显）。</p>
<p>在实际情况下，进行老年代的并发回收时，可能会伴随着多次年轻代的 minor GC。在这种情况下，full GC 的日志中就会掺杂着多次 minor GC 事件.</p>
<blockquote>
<p>总之，<strong>CMS 垃圾收集器在减少停顿时间上做了很多复杂而有用的工作</strong>，用于垃圾回收的并发线程执行的同时，并不需要暂停应用线程。当然，CMS 也有一些缺点，其中最大的问题就是老年代内存碎片问题（因为不压缩），在某些情况下 GC 会造成不可预测的暂停时间，特别是堆内存较大的情况下。</p>
</blockquote>
<h3 id="G1-垃圾收集器"><a href="#G1-垃圾收集器" class="headerlink" title="G1 垃圾收集器"></a>G1 垃圾收集器</h3><blockquote>
<p>G1 的全称是 Garbage-First，意为<strong>垃圾优先</strong>，哪一块的垃圾最多就优先清理它。</p>
</blockquote>
<p><strong>G1 GC 最主要的设计目标是：将 STW 停顿的时间和分布，变成可预期且可配置的。</strong></p>
<p>事实上，G1 GC 是一款软实时垃圾收集器，可以为其设置某项特定的性能指标。例如可以指定：在任意 xx 毫秒时间范围内，STW 停顿不得超过 yy 毫秒。举例说明：任意 1 秒内暂停时间不超过 5 毫秒。G1 GC 会尽力达成这个目标（有很大概率会满足，但并不完全确定）。</p>
<h4 id="G1-GC-的特点"><a href="#G1-GC-的特点" class="headerlink" title="G1 GC 的特点"></a><strong>G1 GC 的特点</strong></h4><p>为了达成可预期停顿时间的指标，G1 GC 有一些独特的实现。</p>
<p>首先，堆不再分成年轻代和老年代，而是划分为多个（通常是 2048 个）可以存放对象的 小块堆区域（smaller heap regions）。每个小块，可能一会被定义成 Eden 区，一会被指定为 Survivor 区或者 Old 区。<strong>在逻辑上，所有的 Eden 区和 Survivor 区合起来就是年轻代，所有的 Old 区拼在一起那就是老年代</strong>，如下图所示：</p>
<p><img src="/../images/G1%E5%86%85%E5%AD%98%E5%88%92%E5%88%86.png" alt="G1内存划分"></p>
<p>这样划分之后，使得 G1 不必每次都去收集整个堆空间，而是以增量的方式来进行处理：每次只处理一部分内存块，称为此次 GC 的回收集（collection set）。每次 GC 暂停都会收集所有年轻代的内存块，但一般只包含部分老年代的内存块，见下图带对号的部分：</p>
<p><img src="/../images/G1%E5%9B%9E%E6%94%B6%E9%9B%86.png" alt="G1回收集"></p>
<p>G1 的另一项创新是，在并发阶段估算每个小堆块存活对象的总数。构建回收集的原则是：<strong>垃圾最多的小块会被优先收集</strong>。这也是 G1 名称的由来。</p>
<p>通过以下选项来指定 G1 垃圾收集器：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="RUBY"><figure class="iseeu highlight /ruby"><table><tr><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+UseG1GC</span> -<span class="variable constant_">XX</span><span class="symbol">:MaxGCPauseMillis=</span><span class="number">50</span></span><br></pre></td></tr></table></figure></div>

<h4 id="G1-GC-常用参数设置"><a href="#G1-GC-常用参数设置" class="headerlink" title="G1 GC 常用参数设置"></a><strong>G1 GC 常用参数设置</strong></h4><ul>
<li><code>-XX:+UseG1GC</code>：启用 G1 GC，JDK 7 和 JDK 8 要求必须显示申请启动 G1 GC；</li>
<li><code>-XX:G1NewSizePercent</code>：初始年轻代占整个 Java Heap 的大小，默认值为 5%；</li>
<li><code>-XX:G1MaxNewSizePercent</code>：最大年轻代占整个 Java Heap 的大小，默认值为 60%；</li>
<li><code>-XX:G1HeapRegionSize</code>：设置每个 Region 的大小，单位 MB，需要为 1、2、4、8、16、32 中的某个值，默认是堆内存的 1&#x2F;2000。如果这个值设置比较大，那么大对象就可以进入 Region 了。</li>
<li><code>-XX:ConcGCThreads</code>：<strong>与 Java 应用一起执行的 GC 线程数量，默认是 Java 线程的 1&#x2F;4</strong>，减少这个参数的数值可能会提升并行回收的效率，提高系统内部吞吐量。如果这个数值过低，参与回收垃圾的线程不足，也会导致并行回收机制耗时加长。</li>
<li><code>-XX:+InitiatingHeapOccupancyPercent</code>（简称 IHOP）：G1 内部并行回收循环启动的阈值，默认为 Java Heap 的 45%。这个可以理解为<strong>老年代使用大于等于 45% 的时候，JVM 会启动垃圾回收。这个值非常重要，它决定了在什么时间启动老年代的并行回收</strong>。</li>
<li><code>-XX:G1HeapWastePercent</code>：G1 停止回收的最小内存大小，默认是堆大小的 5%。GC 会收集所有的 Region 中的对象，但是如果下降到了 5%，就会停下来不再收集了。就是说，不必每次回收就把所有的垃圾都处理完，可以遗留少量的下次处理，这样也降低了单次消耗的时间。</li>
<li><code>-XX:G1MixedGCCountTarget</code>：设置并行循环之后需要有多少个混合 GC 启动，默认值是 8 个。老年代 Regions 的回收时间通常比年轻代的收集时间要长一些。所以如果混合收集器比较多，可以允许 G1 延长老年代的收集时间。</li>
<li><code>-XX:+G1PrintRegionLivenessInfo</code>：这个参数需要和 <code>-XX:+UnlockDiagnosticVMOptions</code> 配合启动，打印 JVM 的调试信息，每个 Region 里的对象存活信息。</li>
<li><code>-XX:G1ReservePercent</code>：G1 为了保留一些空间用于年代之间的提升，默认值是堆空间的 10%。因为大量执行回收的地方在年轻代（存活时间较短），所以如果你的应用里面有比较大的堆内存空间、比较多的大对象存活，这里需要保留一些内存。</li>
<li><code>-XX:+G1SummarizeRSetStats</code>：这也是一个 VM 的调试信息。如果启用，会在 VM 退出的时候打印出 RSets 的详细总结信息。如果启用<code>-XX:G1SummaryRSetStatsPeriod</code>参数，就会阶段性地打印 RSets 信息。</li>
<li><code>-XX:+G1TraceConcRefinement</code>：这个也是一个 VM 的调试信息，如果启用，并行回收阶段的日志就会被详细打印出来。</li>
<li><code>-XX:+GCTimeRatio</code>：大家知道，GC 的有些阶段是需要 Stop—the—World，即停止应用线程的。这个参数就是计算花在 Java 应用线程上和花在 GC 线程上的时间比率，默认是 9，跟新生代内存的分配比例一致。这个参数主要的目的是让用户可以控制花在应用上的时间，G1 的计算公式是 100&#x2F;（1+GCTimeRatio）。这样如果参数设置为 9，则最多 10% 的时间会花在 GC 工作上面。Parallel GC 的默认值是 99，表示 1% 的时间被用在 GC 上面，这是因为 Parallel GC 贯穿整个 GC，而 G1 则根据 Region 来进行划分，不需要全局性扫描整个内存堆。</li>
<li><code>-XX:+UseStringDeduplication</code>：手动开启 Java String 对象的去重工作，这个是 JDK8u20 版本之后新增的参数，主要用于相同 String 避免重复申请内存，节约 Region 的使用。</li>
<li><code>-XX:MaxGCPauseMills</code>：<strong>预期 G1 每次执行 GC 操作的暂停时间，单位是毫秒，默认值是 200 毫秒，G1 会尽量保证控制在这个范围内</strong>。</li>
</ul>
<p>这里面<strong>最重要的参数，就是</strong>：</p>
<ul>
<li><code>-XX:+UseG1GC</code>：启用 G1 GC；</li>
<li><code>-XX:+InitiatingHeapOccupancyPercent</code>：决定什么情况下发生 G1 GC；</li>
<li><code>-XX:MaxGCPauseMills</code>：期望每次 GC 暂定的时间，比如我们设置为 50，则 G1 GC 会通过调节每次 GC 的操作时间，尽量让每次系统的 GC 停顿都在 50 上下浮动。如果某次 GC 时间超过 50ms，比如说 100ms，那么系统会自动在后面动态调整 GC 行为，围绕 50 毫秒浮动。</li>
</ul>
<h4 id="年轻代模式转移暂停（Evacuation-Pause）"><a href="#年轻代模式转移暂停（Evacuation-Pause）" class="headerlink" title="年轻代模式转移暂停（Evacuation Pause）"></a><strong>年轻代模式转移暂停（Evacuation Pause）</strong></h4><p>通过前面的分析可以看到，G1 GC 会通过前面一段时间的运行情况来不断的调整自己的回收策略和行为，以此来比较稳定地控制暂停时间。在应用程序刚启动时，G1 还没有采集到什么足够的信息，这时候就处于初始的 fully-young 模式。<strong>当年轻代空间用满后，应用线程会被暂停，年轻代内存块中的存活对象被拷贝到存活区。如果还没有存活区，则任意选择一部分空闲的内存块作为存活区</strong>。</p>
<p><strong>拷贝的过程称为转移（Evacuation）</strong>，这和前面介绍的其他年轻代收集器是一样的工作原理。</p>
<h4 id="并发标记（Concurrent-Marking）"><a href="#并发标记（Concurrent-Marking）" class="headerlink" title="并发标记（Concurrent Marking）"></a><strong>并发标记（Concurrent Marking）</strong></h4><p>同时我们也可以看到，G1 GC 的很多概念建立在 CMS 的基础上，所以下面的内容需要对 CMS 有一定的理解。</p>
<p>G1 并发标记的过程与 CMS 基本上是一样的。G1 的并发标记通过 <strong>Snapshot-At-The-Beginning（起始快照）</strong> 的方式，在标记阶段开始时记下所有的存活对象。即使在标记的同时又有一些变成了垃圾。通过对象的存活信息，可以构建出每个小堆块的存活状态，以便回收集能高效地进行选择。</p>
<p>这些信息在接下来的阶段会用来执行老年代区域的垃圾收集。</p>
<p>有两种情况是可以完全并发执行的：</p>
<ul>
<li>如果在标记阶段确定某个小堆块中没有存活对象，只包含垃圾；</li>
<li>在 STW 转移暂停期间，同时包含垃圾和存活对象的老年代小堆块。</li>
</ul>
<p>当堆内存的总体使用比例达到一定数值，就会触发并发标记。这个默认比例是 45%，但也可以通过 JVM 参数 <strong>InitiatingHeapOccupancyPercent</strong> 来设置。和 CMS 一样，G1 的并发标记也是由多个阶段组成，其中一些阶段是完全并发的，还有一些阶段则会暂停应用线程。</p>
<h4 id="转移暂停：混合模式（Evacuation-Pause-mixed-）"><a href="#转移暂停：混合模式（Evacuation-Pause-mixed-）" class="headerlink" title="转移暂停：混合模式（Evacuation Pause(mixed)）"></a><strong>转移暂停：混合模式（Evacuation Pause(mixed)）</strong></h4><p>并发标记完成之后，<strong>G1 将执行一次混合收集（mixed collection），就是不只清理年轻代，还将一部分老年代区域也加入到 回收集 中</strong>。混合模式的转移暂停不一定紧跟并发标记阶段。有很多规则和历史数据会影响混合模式的启动时机。比如，假若在老年代中可以并发地腾出很多的小堆块，就没有必要启动混合模式。因此，在并发标记与混合转移暂停之间，很可能会存在多次 young 模式的转移暂停。</p>
<p>具体添加到回收集的老年代小堆块的大小及顺序，也是基于许多规则来判定的。其中包括指定的软实时性能指标，存活性，以及在并发标记期间收集的 GC 效率等数据，外加一些可配置的 JVM 选项。混合收集的过程，很大程度上和前面的 fully-young gc 是一样的。</p>
<h3 id="GC-选择的经验总结"><a href="#GC-选择的经验总结" class="headerlink" title="GC 选择的经验总结"></a>GC 选择的经验总结</h3><p><img src="/../images/GC%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="GC收集器"></p>
<p>综合来看，G1 是 JDK11 之前 HotSpot JVM 中最先进的<strong>准产品级（production-ready）</strong> 垃圾收集器。重要的是，HotSpot 工程师的主要精力都放在不断改进 G1 上面。在更新的 JDK 版本中，将会带来更多强大的功能和优化。</p>
<p>可以看到，<strong>G1 作为 CMS 的代替者出现，解决了 CMS 中的各种疑难问题</strong>，包括<strong>暂停时间的可预测性，并终结了堆内存的碎片化</strong>。对单业务延迟非常敏感的系统来说，如果 CPU 资源不受限制，那么 G1 可以说是 HotSpot 中最好的选择，特别是在最新版本的 JVM 中。当然这种降低延迟的优化也不是没有代价的：由于额外的写屏障和守护线程，G1 的开销会更大。如果系统属于吞吐量优先型的，又或者 CPU 持续占用 100%，而又不在乎单次 GC 的暂停时间，那么 CMS 是更好的选择。</p>
<blockquote>
<p>总之，<strong>G1 适合大内存，需要较低延迟的场景</strong>。</p>
</blockquote>
<p>选择正确的 GC 算法，唯一可行的方式就是去尝试，并找出不合理的地方，一般性的指导原则：</p>
<ul>
<li>如果<strong>系统考虑吞吐优先，CPU 资源都用来最大程度处理业务，用 Parallel GC</strong>；</li>
<li>如果<strong>系统考虑低延迟有限，每次 GC 时间尽量短，用 CMS GC</strong>；</li>
<li>如果系统<strong>内存堆较大，同时希望整体来看平均 GC 时间可控，使用 G1 GC</strong>。</li>
</ul>
<p>对于内存大小的考量：</p>
<ul>
<li>一般 4G 以上，算是比较大，用 G1 的性价比较高。</li>
<li>一般超过 8G，比如 16G-64G 内存，非常推荐使用 G1 GC。</li>
</ul>
<p>最后讨论一个很多开发者经常忽视的问题：</p>
<blockquote>
<p>JDK 8 的默认 GC 是什么？</p>
</blockquote>
<p>很多人或觉得是 CMS，甚至 G1，其实都不是。</p>
<p>答案是：并行 GC 是 JDK8 里的默认 GC 策略。</p>
<p>注意，G1 成为 JDK9 以后版本的默认 GC 策略，同时，ParNew + SerialOld 这种组合不被支持。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java字节码技术</title>
    <url>/posts/441734907.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>JVM调优一</title>
    <url>/posts/4218531220.html</url>
    <content><![CDATA[<p>本文主要介绍JVM基本知识及JVM调优简介和实战案例</p>
<h2 id="JVM基本知识"><a href="#JVM基本知识" class="headerlink" title="JVM基本知识"></a>JVM基本知识</h2><h3 id="什么是-JVM"><a href="#什么是-JVM" class="headerlink" title="什么是 JVM"></a>什么是 JVM</h3><p>JVM 全称是 Java Virtual Machine，中文称为 Java 虚拟机。</p>
<p>JVM 是 Java 程序运行的底层平台，与 Java 支持库一起构成了 Java 程序的执行环境。</p>
<p>分为 JVM 规范和 JVM 实现两个部分。简单来说，Java 虚拟机就是指能执行标准 Java 字节码的虚拟计算机。</p>
<h3 id="JVM相关知识"><a href="#JVM相关知识" class="headerlink" title="JVM相关知识"></a>JVM相关知识</h3><h4 id="JDK-与-JVM-有什么区别？"><a href="#JDK-与-JVM-有什么区别？" class="headerlink" title="JDK 与 JVM 有什么区别？"></a>JDK 与 JVM 有什么区别？</h4><p>现在的 JDK、JRE 和 JVM 一般是整套出现的。</p>
<ul>
<li>JDK &#x3D; JRE + 开发调试诊断工具</li>
<li>JRE &#x3D; JVM + Java 标准库</li>
</ul>
<h3 id="JVM领域"><a href="#JVM领域" class="headerlink" title="JVM领域"></a>JVM领域</h3><p><img src="/../images/JVM%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86.png" alt="JVM组成部分"></p>
<p>从上图可以看到，JVM 可以划分为这些部分：</p>
<ul>
<li>执行引擎，包括：GC、JIT 编译器</li>
<li>类加载子系统，这部分的问题，一般在开发过程中出现</li>
<li>JNI 部分，这部分问题一般在 JVM 之外</li>
<li>运行时数据区；Java 将内存分为 2 大块：堆内存和栈内存</li>
</ul>
<blockquote>
<p>线上环境的<strong>JVM问题主要集中在 GC 和内存部分</strong>。而栈内存、线程分析等问题，主要是辅助诊断 Java 程序本身的问题。</p>
</blockquote>
<h3 id="JVM内存"><a href="#JVM内存" class="headerlink" title="JVM内存"></a>JVM内存</h3><p>JVM 的内存设置是最重要的参数设置，也是 GC 分析和调优的重点。</p>
<blockquote>
<p>JVM 总内存&#x3D;堆+栈+非堆+堆外内存。</p>
</blockquote>
<p>相关的参数：</p>
<ul>
<li><code>-Xmx</code>, 指定最大堆内存。 如 <code>-Xmx4g</code>. 这只是限制了 Heap 部分的最大值为 4g。这个内存不包括栈内存，也不包括堆外使用的内存。</li>
<li><code>-Xms</code>, 指定堆内存空间的初始大小。 如 <code>-Xms4g</code>。 而且指定的内存大小，并不是操作系统实际分配的初始值，而是 GC 先规划好，用到才分配。 专用服务器上需要保持 <code>-Xms</code>和<code>-Xmx</code>一致，否则应用刚启动可能就有好几个 FullGC。当两者配置不一致时，堆内存扩容可能会导致性能抖动。</li>
<li><code>-Xmn</code>, 等价于 <code>-XX:NewSize</code>，使用 G1 垃圾收集器 <strong>不应该</strong> 设置该选项，在其他的某些业务场景下可以设置。官方建议设置为 <code>-Xmx</code> 的 <code>1/2 ~ 1/4</code>。</li>
<li><code>-XX:MaxPermSize=size</code>, 这是 JDK1.7 之前使用的。Java8 默认允许的 Meta 空间无限大，此参数无效。</li>
<li><code>-XX:MaxMetaspaceSize=size</code>, Java8 默认不限制 Meta 空间, 一般不允许设置该选项。</li>
<li><code>XX:MaxDirectMemorySize=size</code>，系统可以使用的最大堆外内存，这个参数跟<code>-Dsun.nio.MaxDirectMemorySize</code>效果相同。</li>
<li><code>-Xss</code>, 设置每个线程栈的字节数。 例如 <code>-Xss1m</code> 指定线程栈为 1MB，与<code>-XX:ThreadStackSize=1m</code>等价</li>
</ul>
<p>这里要特别说一下堆外内存，也就是说不在堆上的内存，我们可以通过jconsole，jvisualvm 等工具查看。</p>
<p>“Direct Memory”，一般来说是 Java NIO 使用的 Direct-X-Buffer（例如 DirectByteBuffer）所分配的 native memory，这个地方如果我们使用 netty 之类的框架，会产生大量的堆外内存。</p>
<h3 id="常用的-JVM-配置参数"><a href="#常用的-JVM-配置参数" class="headerlink" title="常用的 JVM 配置参数"></a>常用的 JVM 配置参数</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置堆内存</span></span><br><span class="line">-Xmx4g -Xms4g </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定 GC 算法</span></span><br><span class="line">-XX:+UseG1GC -XX:MaxGCPauseMillis=50 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定 GC 并行线程数</span></span><br><span class="line">-XX:ParallelGCThreads=4 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印 GC 日志</span></span><br><span class="line">-XX:+PrintGCDetails -XX:+PrintGCDateStamps </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定 GC 日志文件</span></span><br><span class="line">-Xloggc:gc.log </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定 Meta 区的最大值</span></span><br><span class="line">-XX:MaxMetaspaceSize=2g </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置单个线程栈的大小</span></span><br><span class="line">-Xss1m </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定堆内存溢出时自动进行 Dump</span></span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError </span><br><span class="line">-XX:HeapDumpPath=/usr/local/</span><br></pre></td></tr></table></figure></div>

<h3 id="常用属性配置"><a href="#常用属性配置" class="headerlink" title="常用属性配置"></a>常用属性配置</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定默认的连接超时时间</span></span><br><span class="line">-Dsun.net.client.defaultConnectTimeout=2000</span><br><span class="line">-Dsun.net.client.defaultReadTimeout=2000</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定时区</span></span><br><span class="line">-Duser.timezone=GMT+08 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置默认的文件编码为 UTF-8</span></span><br><span class="line">-Dfile.encoding=UTF-8 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定随机数熵源（Entropy Source）</span></span><br><span class="line">-Djava.security.egd=file:/dev/./urandom </span><br></pre></td></tr></table></figure></div>

<h3 id="排查问题常用shell操作"><a href="#排查问题常用shell操作" class="headerlink" title="排查问题常用shell操作"></a>排查问题常用shell操作</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前路径</span></span><br><span class="line">pwd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前目录下有哪些文件</span></span><br><span class="line">ls -l</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看系统负载</span></span><br><span class="line">top</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看剩余内存</span></span><br><span class="line">free -h</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看剩余磁盘</span></span><br><span class="line">df -h</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前目录的使用量</span></span><br><span class="line">du -sh *</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">系统活动情况报告</span></span><br><span class="line">sar</span><br><span class="line">-bash: sar: command not found</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Linux安装sysstat</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">apt-get install sysstat</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">yum -y install sysstat</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看帮助手册</span></span><br><span class="line">man sar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看最近的报告</span></span><br><span class="line">sar 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">???</span></span><br><span class="line">sar -G 1 3</span><br><span class="line">sar: illegal option -- G</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看帮助手册</span></span><br><span class="line">man sar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">......</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="配置多少-xmx-合适"><a href="#配置多少-xmx-合适" class="headerlink" title="配置多少 xmx 合适"></a>配置多少 xmx 合适</h3><p>从上面的分析可以看到，<strong>系统有大量的地方使用堆外内存，远比我们常说的 xmx 和 xms 包括的范围要广</strong>。所以我们需要在设置内存的时候留有余地</p>
<p>实际上，比较推荐配置<strong>系统或容器里可用内存的 70-80% 最好</strong>。比如说系统有 8G 物理内存，系统自己可能会用掉一点，大概还有 7.5G 可以用，那么建议配置</p>
<blockquote>
<p>-Xmx6g 说明：xmx : 7.5G*0.8 &#x3D; 6G，如果知道系统里有明确使用堆外内存的地方，还需要进一步降低这个值。</p>
</blockquote>
<h3 id="xmx-和-xms-是不是要配置成一致的"><a href="#xmx-和-xms-是不是要配置成一致的" class="headerlink" title="xmx 和 xms 是不是要配置成一致的"></a>xmx 和 xms 是不是要配置成一致的</h3><p>一般情况下，我们的服务器是专用的，就是一个机器（也可能是云主机或 docker 容器）只部署一个 Java 应用，这样的时候建议配置成一样的，好处是不会再动态去分配，如果内存不足（像上面的情况）上来就知道。</p>
<h3 id="GC-日志相关的参数"><a href="#GC-日志相关的参数" class="headerlink" title="GC 日志相关的参数"></a>GC 日志相关的参数</h3><p>在生产环境或性能压测环境里，我们用来分析和判断问题的重要数据来源之一就是 GC 日志，JVM 启动参数为我们提供了一些用于控制 GC 日志输出的选项。</p>
<ul>
<li><code>-verbose:gc</code> ：和其他 GC 参数组合使用, 在 GC 日志中输出详细的GC信息。 包括每次 GC 前后各个内存池的大小，堆内存的大小，提升到老年代的大小，以及消耗的时间。此参数支持在运行过程中动态开关。比如使用 jcmd, jinfo， 以及使用 JMX 技术的其他客户端。</li>
<li><code>-XX:+PrintGCDetails</code> 和 <code>-XX:+PrintGCTimeStamps</code>：打印 GC 细节与发生时间。请关注我们后续的 GC 课程章节。</li>
<li><code>-Xloggc:file</code>：与<code>-verbose:gc</code>功能类似，只是将每次 GC 事件的相关情况记录到一个文件中，文件的位置最好在本地，以避免网络的潜在问题。若与 verbose:gc 命令同时出现在命令行中，则以 -Xloggc 为准。</li>
</ul>
<p>示例:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">export JAVA_OPTS=&quot;-Xms28g -Xmx28g -Xss1m \</span><br><span class="line">-verbosegc -XX:+UseG1GC -XX:MaxGCPauseMillis=200 \</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/&quot;</span><br></pre></td></tr></table></figure></div>

<h2 id="指定垃圾收集器相关参数"><a href="#指定垃圾收集器相关参数" class="headerlink" title="指定垃圾收集器相关参数"></a>指定垃圾收集器相关参数</h2><p>垃圾回收器是 JVM 性能分析和调优的核心内容之一，也是近几个 JDK 版本大力发展和改进的地方。通过不同的 GC 算法和参数组合，配合其他调优手段，我们可以把系统精确校验到性能最佳状态。</p>
<p>以下参数指定具体的垃圾收集器，详细情况会在第二部分讲解：</p>
<ul>
<li><code>-XX:+UseG1GC</code>：使用 G1 垃圾回收器</li>
<li><code>-XX:+UseConcMarkSweepGC</code>：使用 CMS 垃圾回收器</li>
<li><code>-XX:+UseSerialGC</code>：使用串行垃圾回收器</li>
<li><code>-XX:+UseParallelGC</code>：使用并行垃圾回收器</li>
</ul>
<h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><p>运行一个 Java 应用程序，我们必须要先安装 JDK 或者 JRE 包。这是因为 Java 应用在编译后会变成字节码，然后通过字节码运行在 JVM 中，而 JVM 是 JRE 的核心组成部分。<strong>JVM 不仅承担了 Java 字节码的分析（JIT compiler）和执行（Runtime），同时也内置了自动内存分配管理机制</strong>。这个机制可以大大降低手动分配回收机制可能带来的内存泄露和内存溢出风险，使 Java 开发人员不需要关注每个对象的内存分配以及回收，从而更专注于业务本身。</p>
<h3 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h3><p>JVM 自动内存分配管理机制的好处很多，但实则是把双刃剑。这个机制在提升 Java 开发效率的同时，也容易使 Java 开发人员过度依赖于自动化，弱化对内存的管理能力，这样系统就很容易发生 JVM 的堆内存异常，垃圾回收（GC）的方式不合适以及 GC 次数过于频繁等问题，这些都将直接影响到应用服务的性能。</p>
<p>因此，要进行 JVM 层面的调优，就需要深入了解 JVM 内存分配和回收原理，这样在遇到问题时，我们才能通过日志分析快速地定位问题；也能在系统遇到性能瓶颈时，通过分析 JVM 调优来优化系统性能。</p>
<h4 id="JVM-内存模型的具体设计"><a href="#JVM-内存模型的具体设计" class="headerlink" title="JVM 内存模型的具体设计"></a>JVM 内存模型的具体设计</h4><p>在 Java 中，JVM 内存模型主要分为堆、程序计数器、方法区、虚拟机栈和本地方法栈。</p>
<p><img src="/../images/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="JVM内存模型"></p>
<h5 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h5><p>堆是 JVM 内存中最大的一块内存空间，该内存被所有线程共享，几乎所有对象和数组都被分配到了堆内存中。堆被划分为新生代和老年代，新生代又被进一步划分为 Eden 和 Survivor 区，最后 Survivor 由 From Survivor 和 To Survivor 组成。</p>
<p>在 Java6 版本中，永久代在非堆内存区；到了 Java7 版本，永久代的静态变量和运行时常量池被合并到了堆中；而到了 Java8，永久代被元空间取代了。 结构如下图所示：</p>
<p><img src="/../images/JVM%E5%86%85%E5%AD%98%E7%89%88%E6%9C%AC%E5%AF%B9%E6%AF%94.png" alt="JVM内存版本对比"></p>
<h5 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h5><p>程序计数器是一块很小的内存空间，主要用来记录各个线程执行的字节码的地址，例如，分支、循环、跳转、异常、线程恢复等都依赖于计数器。</p>
<p>由于 Java 是多线程语言，当执行的线程数量超过 CPU 核数时，线程之间会根据时间片轮询争夺 CPU 资源。如果一个线程的时间片用完了，或者是其它原因导致这个线程的 CPU 资源被提前抢夺，那么这个退出的线程就需要单独的一个程序计数器，来记录下一条运行的指令。</p>
<h5 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h5><p>很多开发者都习惯将方法区称为“永久代”，其实这两者并不是等价的。</p>
<p>HotSpot 虚拟机使用永久代来实现方法区，但在其它虚拟机中，例如，Oracle 的 JRockit、IBM 的 J9 就不存在永久代一说。因此，方法区只是 JVM 中规范的一部分，可以说，在 HotSpot 虚拟机中，设计人员使用了永久代来实现了 JVM 规范的方法区。</p>
<p><strong>方法区主要是用来存放已被虚拟机加载的类相关信息，包括类信息、运行时常量池、字符串常量池</strong>。类信息又包括了类的版本、字段、方法、接口和父类等信息。</p>
<p>JVM 在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。在加载类的时候，JVM 会先加载 class 文件，而在 class 文件中除了有类的版本、字段、方法和接口等描述信息外，还有一项信息是常量池 (Constant Pool Table)，用于存放编译期间生成的各种字面量和符号引用。</p>
<p>字面量包括字符串（String a&#x3D;“b”）、基本类型的常量（final 修饰的变量），符号引用则包括类和方法的全限定名（例如 String 这个类，它的全限定名就是 Java&#x2F;lang&#x2F;String）、字段的名称和描述符以及方法的名称和描述符。</p>
<p>而当类加载到内存中后，JVM 就会将 class 文件常量池中的内容存放到运行时的常量池中；在解析阶段，JVM 会把符号引用替换为直接引用（对象的索引值）。</p>
<p>例如，类中的一个字符串常量在 class 文件中时，存放在 class 文件常量池中的；在 JVM 加载完类之后，JVM 会将这个字符串常量放到运行时常量池中，并在解析阶段，指定该字符串对象的索引值。运行时常量池是全局共享的，多个类共用一个运行时常量池，class 文件中常量池多个相同的字符串在运行时常量池只会存在一份。</p>
<p>方法区与堆空间类似，也是一个共享内存区，所以<strong>方法区是线程共享的</strong>。假如两个线程都试图访问方法区中的同一个类信息，而这个类还没有装入 JVM，那么此时就只允许一个线程去加载它，另一个线程必须等待。在 HotSpot 虚拟机、Java7 版本中已经将永久代的静态变量和运行时常量池转移到了堆中，其余部分则存储在 JVM 的非堆内存中，而 Java8 版本已经将方法区中实现的永久代去掉了，并用元空间（class metadata）代替了之前的永久代，并且元空间的存储位置是本地</p>
<h5 id="虚拟机栈（VM-stack）"><a href="#虚拟机栈（VM-stack）" class="headerlink" title="虚拟机栈（VM stack）"></a>虚拟机栈（VM stack）</h5><p>Java 虚拟机栈是线程私有的内存空间，它和 Java 线程一起创建。当创建一个线程时，会在虚拟机栈中申请一个线程栈，用来保存方法的局部变量、操作数栈、动态链接方法和返回地址等信息，并参与方法的调用和返回。每一个方法的调用都伴随着栈帧的入栈操作，方法的返回则是栈帧的出栈操作。</p>
<h5 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h5><p>本地方法栈跟 Java 虚拟机栈的功能类似，Java 虚拟机栈用于管理 Java 函数的调用，而本地方法栈则用于管理本地方法的调用。但本地方法并不是用 Java 实现的，而是由 C 语言实现的。</p>
<h3 id="JVM-的运行原理"><a href="#JVM-的运行原理" class="headerlink" title="JVM 的运行原理"></a>JVM 的运行原理</h3><p>接下来，通过一个案例来了解下代码和对象是如何分配存储的，Java 代码又是如何在 JVM 中运行的。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JVMCase</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 常量</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">MAN_SEX_TYPE</span> <span class="operator">=</span> <span class="string">&quot;man&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 静态变量</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">WOMAN_SEX_TYPE</span> <span class="operator">=</span> <span class="string">&quot;woman&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    stu.setName(<span class="string">&quot;nick&quot;</span>);</span><br><span class="line">    stu.setSexType(MAN_SEX_TYPE);</span><br><span class="line">    stu.setAge(<span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">JVMCase</span> <span class="variable">jvmcase</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JVMCase</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用静态方法</span></span><br><span class="line">    print(stu);</span><br><span class="line">    <span class="comment">// 调用非静态方法</span></span><br><span class="line">    jvmcase.sayHello(stu);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 常规静态方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Student stu)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;name: &quot;</span> + stu.getName() + <span class="string">&quot;; sex:&quot;</span> + stu.getSexType() + <span class="string">&quot;; age:&quot;</span> + stu.getAge()); </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 非静态方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(Student stu)</span> &#123;</span><br><span class="line">    System.out.println(stu.getName() + <span class="string">&quot;say: hello&quot;</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  String sexType;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getSexType</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sexType;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSexType</span><span class="params">(String sexType)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.sexType = sexType;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>当我们通过 Java 运行以上代码时，JVM 的整个处理过程如下</strong>：</p>
<ol>
<li><p>JVM 向操作系统申请内存，JVM 第一步就是通过配置参数或者默认配置参数向操作系统申请内存空间，根据内存大小找到具体的内存分配表，然后把内存段的起始地址和终止地址分配给 JVM，接下来 JVM 就进行内部分配。</p>
</li>
<li><p>JVM 获得内存空间后，会根据配置参数分配堆、栈以及方法区的内存大小。</p>
</li>
<li><p>class 文件加载、验证、准备以及解析，其中准备阶段会为类的静态变量分配内存，初始化为系统的初始值。</p>
<p><img src="/../images/%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5.png" alt="初始化阶段"></p>
</li>
<li><p>完成上一个步骤后，将会进行最后一个初始化阶段。在这个阶段中，JVM 首先会执行构造器 方法，编译器会在.java 文件被编译成.class 文件时，收集所有类的初始化代码，包括静态变量赋值语句、静态代码块、静态方法，收集在一起成为 () 方法。</p>
<p><img src="/../images/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%961.png" alt="类初始化1"></p>
</li>
<li><p>执行方法。启动 main 线程，执行 main 方法，开始执行第一行代码。此时堆内存中会创建一个 student 对象，对象引用 student 就存放在栈中</p>
<p><img src="/../images/%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%962.png" alt="类初始化2"></p>
</li>
<li><p>此时再次创建一个 JVMCase 对象，调用 sayHello 非静态方法，sayHello 方法属于对象 JVMCase，此时 sayHello 方法入栈，并通过栈中的 student 引用调用堆中的 Student 对象；之后，调用静态方法 print，print 静态方法属于 JVMCase 类，是从静态方法中获取，之后放入到栈中，也是通过 student 引用调用堆中的 student 对象。</p>
<p><img src="/../images/%E5%BC%95%E7%94%A8%E5%A0%86%E5%AF%B9%E8%B1%A1.png" alt="引用堆对象"></p>
</li>
</ol>
<p>了解完实际代码在 JVM 中分配的内存空间以及运行原理，相信会更加清楚内存模型中各个区域的职责分工。</p>
<blockquote>
<p>可以使用不同的引用类型，改变一个对象的正常生命周期，从而提高 JVM 的回收效率，这也是 JVM 性能调优的一种方式</p>
</blockquote>
<h2 id="JVM调优案例"><a href="#JVM调优案例" class="headerlink" title="JVM调优案例"></a>JVM调优案例</h2><p><strong>背景：</strong>老年代空间的使用量在缓慢上升，并没有下降，引发最大暂停时间的这个点并没有发生 FullGC。</p>
<p>从监控图可以看到老年代对应的内存池是 “ps_old_gen”，通过前面的学习，我们知道，ps 代表的是 ParallelGC 垃圾收集器。</p>
<blockquote>
<p>JDK 8默认并行垃圾收集器, ParallelGC 为了最大的系统处理能力，即吞吐量，而牺牲掉了单次的暂停时间，导致暂停时间会比较长</p>
</blockquote>
<blockquote>
<p>为什么有怀疑呢，因为 Datadog 这个监控系统，默认 10s 上报一次数据。有可能在这 10s 内发生些什么事情但是被漏报了（当然，这是不可能的，如果上报失败会在日志系统中打印相关的错误）。</p>
</blockquote>
<p>再分析上面这个图，可以看到老年代对应的内存池是 “ps_old_gen”，通过前面的学习，我们知道，ps 代表的是 ParallelGC 垃圾收集器。</p>
<p><strong>JVM 启动参数</strong></p>
<p>查看 JVM 的启动参数，发现是这样的：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DIFF"><figure class="iseeu highlight /diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-Xmx4g -Xms4g</span></span><br></pre></td></tr></table></figure></div>

<p>我们使用的是 JDK 8，启动参数中没有指定 GC，确定这个服务使用了默认的并行垃圾收集器。</p>
<p>于是怀疑问题出在这款垃圾收集器上面，因为很多情况下 ParallelGC 为了最大的系统处理能力，即吞吐量，而牺牲掉了单次的暂停时间，导致暂停时间会比较长。</p>
<h3 id="使用-G1-垃圾收集器"><a href="#使用-G1-垃圾收集器" class="headerlink" title="使用 G1 垃圾收集器"></a>使用 G1 垃圾收集器</h3><p>换成 G1，毕竟现在新版本的 JDK 8 中 G1 很稳定，而且性能不错。</p>
<p>然后换成了下面的启动参数：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="RUBY"><figure class="iseeu highlight /ruby"><table><tr><td class="code"><pre><span class="line">-<span class="title class_">Xmx4g</span> -<span class="title class_">Xms4g</span> -<span class="variable constant_">XX</span><span class="symbol">:+UseG1GC</span> -<span class="variable constant_">XX</span><span class="symbol">:MaxGCPauseMillis=</span><span class="number">50</span></span><br></pre></td></tr></table></figure></div>

<p>运行一段时间后，最大 GC 暂停时间达到了 1300ms。</p>
<p>情况似乎更恶劣了。</p>
<p>进一步查看日志信息：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JSON"><figure class="iseeu highlight /json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;duration&quot;</span><span class="punctuation">:</span><span class="number">1869</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;maxPauseMillis&quot;</span><span class="punctuation">:</span><span class="number">1869</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;promotedBytes&quot;</span><span class="punctuation">:</span><span class="string">&quot;139MB&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;gcCause&quot;</span><span class="punctuation">:</span><span class="string">&quot;G1 Evacuation Pause&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;collectionTime&quot;</span><span class="punctuation">:</span><span class="number">27281</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;gcAction&quot;</span><span class="punctuation">:</span><span class="string">&quot;end of minor GC&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;afterUsage&quot;</span><span class="punctuation">:</span></span><br><span class="line"> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;G1 Old Gen&quot;</span><span class="punctuation">:</span><span class="string">&quot;1745MB&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Code Cache&quot;</span><span class="punctuation">:</span><span class="string">&quot;53MB&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;G1 Survivor Space&quot;</span><span class="punctuation">:</span><span class="string">&quot;254MB&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Compressed Class Space&quot;</span><span class="punctuation">:</span><span class="string">&quot;9MB&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;Metaspace&quot;</span><span class="punctuation">:</span><span class="string">&quot;81MB&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;G1 Eden Space&quot;</span><span class="punctuation">:</span><span class="string">&quot;0&quot;</span></span><br><span class="line"> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;gcId&quot;</span><span class="punctuation">:</span><span class="number">326</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;collectionCount&quot;</span><span class="punctuation">:</span><span class="number">326</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;gcName&quot;</span><span class="punctuation">:</span><span class="string">&quot;G1 Young Generation&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;jvm.gc.pause&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></div>

<p>这次不是 FullGC，而是年轻代 GC，而且暂停时间达到了 1869ms。 一点道理都不讲，我认为这种情况不合理，而且观察 CPU 使用量也不高。</p>
<h4 id="打印-GC-日志"><a href="#打印-GC-日志" class="headerlink" title="打印 GC 日志"></a>打印 GC 日志</h4><p>修改打印 GC 日志启动参数如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">-Xmx4g -Xms4g -XX:+UseG1GC -XX:MaxGCPauseMillis=50 </span><br><span class="line">-Xloggc:gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps</span><br></pre></td></tr></table></figure></div>

<p>重新启动，希望这次能排查出问题的原因。</p>
<p>运行一段时间，又发现了超长的暂停时间。</p>
<h4 id="分析-GC-日志"><a href="#分析-GC-日志" class="headerlink" title="分析 GC 日志"></a><strong>分析 GC 日志</strong></h4><p>因为不涉及敏感数据，那么我们把 GC 日志下载到本地进行分析。</p>
<p>定位到这次暂停时间超长的 GC 事件，关键的信息如下所示：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="C"><figure class="iseeu highlight /c"><table><tr><td class="code"><pre><span class="line">Java <span class="title function_">HotSpot</span><span class="params">(TM)</span> 64-Bit Server <span class="title function_">VM</span> <span class="params">(<span class="number">25.162</span>-b12)</span> <span class="keyword">for</span> linux-amd64 <span class="title function_">JRE</span> <span class="params">(<span class="number">1.8</span><span class="number">.0</span>_162-b12)</span>,</span><br><span class="line"> built on Dec 19 2017 21:15:48 by &quot;java_re&quot; with gcc 4.3.0 20080428 <span class="params">(Red Hat <span class="number">4.3</span><span class="number">.0</span><span class="number">-8</span>)</span></span><br><span class="line">Memory: 4k page, physical 144145548<span class="title function_">k</span><span class="params">(<span class="number">58207948</span>k <span class="built_in">free</span>)</span>, swap 0<span class="title function_">k</span><span class="params">(<span class="number">0</span>k <span class="built_in">free</span>)</span></span><br><span class="line">CommandLine flags: </span><br><span class="line"> -XX:InitialHeapSize=<span class="number">4294967296</span> -XX:MaxGCPauseMillis=<span class="number">50</span> -XX:MaxHeapSize=<span class="number">4294967296</span> </span><br><span class="line"> -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps </span><br><span class="line"> -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC </span><br><span class="line"></span><br><span class="line"><span class="number">2020</span><span class="number">-02</span><span class="number">-24</span>T18:<span class="number">02</span>:<span class="number">31.853</span>+<span class="number">0800</span>: <span class="number">2411.124</span>: [GC pause (G1 Evacuation Pause) (young), <span class="number">1.8683418</span> secs]</span><br><span class="line">   [Parallel Time: <span class="number">1861.0</span> ms, GC Workers: <span class="number">48</span>]</span><br><span class="line">      [GC Worker Start (ms): Min: <span class="number">2411124.3</span>, Avg: <span class="number">2411125.4</span>, Max: <span class="number">2411126.2</span>, Diff: <span class="number">1.9</span>]</span><br><span class="line">      [Ext Root Scanning (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.3</span>, Max: <span class="number">2.7</span>, Diff: <span class="number">2.7</span>, Sum: <span class="number">16.8</span>]</span><br><span class="line">      [Update RS (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">3.6</span>, Max: <span class="number">6.8</span>, Diff: <span class="number">6.8</span>, Sum: <span class="number">172.9</span>]</span><br><span class="line">         [Processed Buffers: Min: <span class="number">0</span>, Avg: <span class="number">2.3</span>, Max: <span class="number">8</span>, Diff: <span class="number">8</span>, Sum: <span class="number">111</span>]</span><br><span class="line">      [Scan RS (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.2</span>, Max: <span class="number">0.5</span>, Diff: <span class="number">0.5</span>, Sum: <span class="number">7.7</span>]</span><br><span class="line">      [Code Root Scanning (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.0</span>, Max: <span class="number">0.1</span>, Diff: <span class="number">0.1</span>, Sum: <span class="number">0.3</span>]</span><br><span class="line">      [Object Copy (ms): Min: <span class="number">1851.6</span>, Avg: <span class="number">1854.6</span>, Max: <span class="number">1857.4</span>, Diff: <span class="number">5.8</span>, Sum: <span class="number">89020.4</span>]</span><br><span class="line">      [Termination (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.0</span>, Max: <span class="number">0.0</span>, Diff: <span class="number">0.0</span>, Sum: <span class="number">0.6</span>]</span><br><span class="line">         [Termination Attempts: Min: <span class="number">1</span>, Avg: <span class="number">1.0</span>, Max: <span class="number">1</span>, Diff: <span class="number">0</span>, Sum: <span class="number">48</span>]</span><br><span class="line">      [GC Worker Other (ms): Min: <span class="number">0.0</span>, Avg: <span class="number">0.3</span>, Max: <span class="number">0.7</span>, Diff: <span class="number">0.6</span>, Sum: <span class="number">14.7</span>]</span><br><span class="line">      [GC Worker Total (ms): Min: <span class="number">1858.0</span>, Avg: <span class="number">1859.0</span>, Max: <span class="number">1860.3</span>, Diff: <span class="number">2.3</span>, Sum: <span class="number">89233.3</span>]</span><br><span class="line">      [GC Worker End (ms): Min: <span class="number">2412984.1</span>, Avg: <span class="number">2412984.4</span>, Max: <span class="number">2412984.6</span>, Diff: <span class="number">0.5</span>]</span><br><span class="line">   [Code Root Fixup: <span class="number">0.0</span> ms]</span><br><span class="line">   [Code Root Purge: <span class="number">0.0</span> ms]</span><br><span class="line">   [Clear CT: <span class="number">1.5</span> ms]</span><br><span class="line">   [Other: <span class="number">5.8</span> ms]</span><br><span class="line">      [Choose CSet: <span class="number">0.0</span> ms]</span><br><span class="line">      [Ref Proc: <span class="number">1.7</span> ms]</span><br><span class="line">      [Ref Enq: <span class="number">0.0</span> ms]</span><br><span class="line">      [Redirty Cards: <span class="number">1.1</span> ms]</span><br><span class="line">      [Humongous Register: <span class="number">0.1</span> ms]</span><br><span class="line">      [Humongous Reclaim: <span class="number">0.0</span> ms]</span><br><span class="line">      [Free CSet: <span class="number">2.3</span> ms]</span><br><span class="line">   [Eden: <span class="number">2024.0</span>M(<span class="number">2024.0</span>M)-&gt;<span class="number">0.0B</span>(<span class="number">2048.0</span>K) </span><br><span class="line">    Survivors: <span class="number">2048.0</span>K-&gt;<span class="number">254.0</span>M </span><br><span class="line">    Heap: <span class="number">3633.6</span>M(<span class="number">4096.0</span>M)-&gt;<span class="number">1999.3</span>M(<span class="number">4096.0</span>M)]</span><br><span class="line"> [Times: user=<span class="number">1.67</span> sys=<span class="number">14.00</span>, real=<span class="number">1.87</span> secs] </span><br></pre></td></tr></table></figure></div>

<p>前后的 GC 事件都很正常，也没发现 FullGC 或者并发标记周期，但找到了几个可疑的点：</p>
<ul>
<li><code>physical 144145548k(58207948k free)</code>：JVM 启动时，物理内存 137GB，空闲内存 55GB。</li>
<li><code>[Parallel Time: 1861.0 ms, GC Workers: 48]</code>：垃圾收集器工作线程 48 个。</li>
</ul>
<p><strong>分析 GC 日志：</strong></p>
<ul>
<li><code>user=1.67</code>：用户线程耗时 1.67s；</li>
<li><code>sys=14.00</code>：系统调用和系统等待时间 14s；</li>
<li><code>real=1.87 secs</code>：实际暂停时间 1.87s；</li>
<li>GC 之前，年轻代使用量 2GB，堆内存使用量 3.6GB，存活区 2MB，可推断出老年代使用量 1.6GB；</li>
<li>GC 之后，年轻代使用量为 0，堆内存使用量 2GB，存活区 254MB，那么老年代大约 1.8GB，那么“内存提升量为 200MB 左右”。</li>
</ul>
<p>这样分析之后，可以得出结论：</p>
<ul>
<li>年轻代转移暂停，复制了 400MB 左右的对象，却消耗了 1.8s，系统调用和系统等待的时间达到了 14s。</li>
<li>JVM 看到的物理内存 137GB。</li>
<li>推算出 JVM 看到的 CPU 内核数量 72个，因为 GC 工作线程 <code>72* 5/8 ~= 48</code> 个。</li>
</ul>
<p>看到这么多的 GC 工作线程我就开始警惕了，毕竟堆内存才指定了 4GB。</p>
<p>按照一般的 CPU 和内存资源配比，常见的比例差不多是 4 核 4GB、4 核 8GB 这样的。</p>
<p>看看对应的 CPU 负载监控信息：</p>
<p><img src="/../images/CPU%E8%B4%9F%E8%B4%A3%E4%BF%A1%E6%81%AF.png" alt="CPU负责信息"></p>
<p>这个节点的配置被限制为 4 核 8GB。</p>
<p>这样一来，GC 暂停时间过长的原因就定位到了：</p>
<ul>
<li>K8S 的资源隔离和 JVM 未协调好，导致 JVM 看见了 72 个 CPU 内核，默认的并行 GC 线程设置为 <code>72* 5/8 ~= 48 个</code>，但是 K8S 限制了这个 Pod 只能使用 4 个 CPU 内核的计算量，致使 GC 发生时，48 个线程在 4 个 CPU 核心上发生资源竞争，导致大量的上下文切换。</li>
</ul>
<p>处置措施为：</p>
<ul>
<li>限制 GC 的并行线程数量</li>
</ul>
<p>事实证明，打印 GC 日志确实是一个很有用的排查分析方法。</p>
<h4 id="限制-GC-的并行线程数量"><a href="#限制-GC-的并行线程数量" class="headerlink" title="限制 GC 的并行线程数量"></a><strong>限制 GC 的并行线程数量</strong></h4><p>下面是新的启动参数配置：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="RUBY"><figure class="iseeu highlight /ruby"><table><tr><td class="code"><pre><span class="line">-<span class="title class_">Xmx4g</span> -<span class="title class_">Xms4g</span></span><br><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:+UseG1GC</span> -<span class="variable constant_">XX</span><span class="symbol">:MaxGCPauseMillis=</span><span class="number">50</span> -<span class="variable constant_">XX</span><span class="symbol">:ParallelGCThreads=</span><span class="number">4</span></span><br><span class="line">-<span class="title class_">Xloggc</span><span class="symbol">:gc</span>.log -<span class="variable constant_">XX</span><span class="symbol">:+PrintGCDetails</span> -<span class="variable constant_">XX</span><span class="symbol">:+PrintGCDateStamps</span></span><br></pre></td></tr></table></figure></div>

<p>这里指定了 <code>-XX:ParallelGCThreads=4</code>，为什么这么配呢？我们看看这个参数的说明。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="RUBY"><figure class="iseeu highlight /ruby"><table><tr><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:ParallelGCThreads=n</span></span><br></pre></td></tr></table></figure></div>

<p>设置 STW 阶段的并行 worker 线程数量。 如果逻辑处理器小于等于 8 个，则默认值 n 等于逻辑处理器的数量。</p>
<p>如果逻辑处理器大于 8 个，则默认值 n 大约等于处理器数量的 5&#x2F;8。在大多数情况下都是个比较合理的值。如果是高配置的 SPARC 系统，则默认值 n 大约等于逻辑处理器数量的 5&#x2F;16。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="RUBY"><figure class="iseeu highlight /ruby"><table><tr><td class="code"><pre><span class="line">-<span class="variable constant_">XX</span><span class="symbol">:ConcGCThreads=n</span></span><br></pre></td></tr></table></figure></div>

<p>设置并发标记的 GC 线程数量。默认值大约是 ParallelGCThreads 的四分之一。</p>
<p><strong>一般来说不用指定并发标记的 GC 线程数量，只用指定并行的即可。</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/posts/40057382.html</url>
    <content><![CDATA[<p>本文讲解位运算相关原理</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>0s 表示一串 0，1s 表示一串 1。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">x ^ 0s = x      x &amp; 0s = <span class="number">0</span>      x | 0s = x</span><br><span class="line">x ^ 1s = ~x     x &amp; 1s = x      x | 1s = 1s</span><br><span class="line">x ^ x = <span class="number">0</span>       x &amp; x = x       x | x = x</span><br></pre></td></tr></table></figure></div>

<p>利用 x ^ 1s &#x3D; ~x 的特点，可以将一个数的位级表示翻转；利用 x ^ x &#x3D; 0 的特点，可以将三个数中重复的两个数去除，只留下另一个数。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>^<span class="number">1</span>^<span class="number">2</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure></div>

<p>利用 x &amp; 0s &#x3D; 0 和 x &amp; 1s &#x3D; x 的特点，可以实现掩码操作。一个数 num 与 mask：00111100 进行位与操作，只保留 num 中与 mask 的 1 部分相对应的位。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="number">01011011</span> &amp;</span><br><span class="line"><span class="number">00111100</span></span><br><span class="line">--------</span><br><span class="line"><span class="number">00011000</span></span><br></pre></td></tr></table></figure></div>

<p>利用 x | 0s &#x3D; x 和 x | 1s &#x3D; 1s 的特点，可以实现设值操作。一个数 num 与 mask：00111100 进行位或操作，将 num 中与 mask 的 1 部分相对应的位都设置为 1。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="number">01011011</span> |</span><br><span class="line"><span class="number">00111100</span></span><br><span class="line">--------</span><br><span class="line"><span class="number">01111111</span></span><br></pre></td></tr></table></figure></div>

<h3 id="位与运算技巧"><a href="#位与运算技巧" class="headerlink" title="位与运算技巧"></a>位与运算技巧</h3><p>n&amp;(n-1) 去除 n 的位级表示中最低的那一位 1。例如对于二进制表示 01011011，减去 1 得到 01011010，这两个数相与得到 01011010。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="number">01011011</span> &amp;</span><br><span class="line"><span class="number">01011010</span></span><br><span class="line">--------</span><br><span class="line"><span class="number">01011010</span></span><br></pre></td></tr></table></figure></div>

<p>n&amp;(-n) 得到 n 的位级表示中最低的那一位 1。-n 得到 n 的反码加 1，也就是 -n&#x3D;~n+1。例如对于二进制表示 10110100，-n 得到 01001100，相与得到 00000100。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="number">10110100</span> &amp;</span><br><span class="line"><span class="number">01001100</span></span><br><span class="line">--------</span><br><span class="line"><span class="number">00000100</span></span><br></pre></td></tr></table></figure></div>

<p>n-(n&amp;(-n)) 则可以去除 n 的位级表示中最低的那一位 1，和 n&amp;(n-1) 效果一样。</p>
<h4 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h4><p>&gt;&gt; n 为算术右移，相当于除以 2n，例如 -7 &gt;&gt; 2 &#x3D; -2。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="number">11111111111111111111111111111001</span>  &gt;&gt; <span class="number">2</span></span><br><span class="line">--------</span><br><span class="line"><span class="number">11111111111111111111111111111110</span></span><br></pre></td></tr></table></figure></div>

<p>&gt;&gt;&gt; n 为无符号右移，左边会补上 0。例如 -7 &gt;&gt;&gt; 2 &#x3D; 1073741822。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="number">11111111111111111111111111111001</span>  &gt;&gt;&gt; <span class="number">2</span></span><br><span class="line">--------</span><br><span class="line"><span class="number">00111111111111111111111111111111</span></span><br></pre></td></tr></table></figure></div>

<p>&lt;&lt; n 为算术左移，相当于乘以 2n。-7 &lt;&lt; 2 &#x3D; -28。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="number">11111111111111111111111111111001</span>  &lt;&lt; <span class="number">2</span></span><br><span class="line">--------</span><br><span class="line"><span class="number">11111111111111111111111111100100</span></span><br></pre></td></tr></table></figure></div>

<h4 id="mask-计算"><a href="#mask-计算" class="headerlink" title="mask 计算"></a>mask 计算</h4><p>要获取 111111111，将 0 取反即可，~0。</p>
<p><strong>要得到只有第 i 位为 1 的 mask，将 1 向左移动 i-1 位即可，1&lt;&lt;(i-1)</strong> 。例如 1&lt;&lt;4 得到只有第 5 位为 1 的 mask ：00010000。</p>
<p>要得到 1 到 i 位为 1 的 mask，(1&lt;&lt;i)-1 即可，例如将 (1&lt;&lt;4)-1 &#x3D; 00010000-1 &#x3D; 00001111。</p>
<p>要得到 1 到 i 位为 0 的 mask，只需将 1 到 i 位为 1 的 mask 取反，即 ~((1&lt;&lt;i)-1)。</p>
<p>对于 10000000 这样的数要扩展成 11111111，可以利用以下方法：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">mask |= mask &gt;&gt; <span class="number">1</span>    <span class="number">11000000</span></span><br><span class="line">mask |= mask &gt;&gt; <span class="number">2</span>    <span class="number">11110000</span></span><br><span class="line">mask |= mask &gt;&gt; <span class="number">4</span>    <span class="number">11111111</span></span><br></pre></td></tr></table></figure></div>

<h4 id="Java-中的位操作"><a href="#Java-中的位操作" class="headerlink" title="Java 中的位操作"></a>Java 中的位操作</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> Integer.bitCount();           <span class="comment">// 统计 1 的数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> Integer.highestOneBit();      <span class="comment">// 获得最高位</span></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">toBinaryString</span><span class="params">(<span class="type">int</span> i)</span>;     <span class="comment">// 转换为二进制表示的字符串</span></span><br><span class="line"><span class="keyword">static</span> String Integer.toString(num, n)   <span class="comment">// 转换为n进制的字符串</span></span><br></pre></td></tr></table></figure></div>

<h4 id="不用额外变量交换两个整数"><a href="#不用额外变量交换两个整数" class="headerlink" title="不用额外变量交换两个整数"></a>不用额外变量交换两个整数</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure></div>

<h2 id="位运算相关算法案例"><a href="#位运算相关算法案例" class="headerlink" title="位运算相关算法案例"></a>位运算相关算法案例</h2><h3 id="1-实现整数的加法-Sum-of-Two-Integers"><a href="#1-实现整数的加法-Sum-of-Two-Integers" class="headerlink" title="1.实现整数的加法(Sum of Two Integers)"></a>1.实现整数的加法(Sum of Two Integers)</h3><p><strong>a ^ b 表示没有考虑进位的情况下两数的和，(a &amp; b) &lt;&lt; 1 就是进位。</strong></p>
<p>递归会终止的原因是 (a &amp; b) &lt;&lt; 1 最右边会多一个 0，那么继续递归，进位最右边的 0 会慢慢增多，最后进位会变为 0，递归终止。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : getSum((a ^ b), (a &amp; b) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="2-数组中唯一一个不重复的元素"><a href="#2-数组中唯一一个不重复的元素" class="headerlink" title="2.数组中唯一一个不重复的元素"></a>2.数组中唯一一个不重复的元素</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="TXT"><figure class="iseeu highlight /txt"><table><tr><td class="code"><pre><span class="line">Input: [4,1,2,1,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></div>

<p>两个相同的数异或的结果为 0，对所有数进行异或操作，最后的结果就是单独出现的那个数。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : nums) ret = ret ^ n;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-找出数组中缺失的那个数"><a href="#3-找出数组中缺失的那个数" class="headerlink" title="3.找出数组中缺失的那个数"></a>3.找出数组中缺失的那个数</h3><p>描述：数组元素在 0-n 之间，但是有一个数是缺失的，要求找到这个缺失的数。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="TXT"><figure class="iseeu highlight /txt"><table><tr><td class="code"><pre><span class="line">Input: [3,0,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></div>

<p>代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        ret = ret ^ i ^ nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ^ nums.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="4-数组中不重复的两个元素"><a href="#4-数组中不重复的两个元素" class="headerlink" title="4.数组中不重复的两个元素"></a>4.数组中不重复的两个元素</h3><p>两个不相等的元素在位级表示上必定会有一位存在不同。</p>
<p>将数组的所有元素异或得到的结果为不存在重复的两个元素异或的结果。</p>
<p><strong>diff &amp;&#x3D; -diff 得到出 diff 最右侧不为 0 的位</strong>，也就是不存在重复的两个元素在位级表示上最右侧不同的那一位，利用这一位就可以将两个元素区分开来。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] singleNumber(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) diff ^= num;</span><br><span class="line">    diff &amp;= -diff;  <span class="comment">// 得到最右一位</span></span><br><span class="line">    <span class="type">int</span>[] ret = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((num &amp; diff) == <span class="number">0</span>) ret[<span class="number">0</span>] ^= num;</span><br><span class="line">        <span class="keyword">else</span> ret[<span class="number">1</span>] ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="5-求一个数的补码"><a href="#5-求一个数的补码" class="headerlink" title="5.求一个数的补码"></a>5.求一个数的补码</h3><p>描述：不考虑二进制表示中的首 0 部分。</p>
<p>对于 00000101，要求补码可以将它与 00000111 进行异或操作。那么问题就转换为求掩码 00000111。</p>
<p><strong>method1：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findComplement</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">while</span> ((num &amp; mask) == <span class="number">0</span>) mask &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    mask = (mask &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> num ^ mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>**method2:**可以利用 Java 的 Integer.highestOneBit() 方法来获得含有首 1 的数。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findComplement</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> Integer.highestOneBit(num);</span><br><span class="line">    mask = (mask &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> num ^ mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>**method3:**对于 10000000 这样的数要扩展成 11111111，可以利用以下方法：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">mask |= mask &gt;&gt; <span class="number">1</span>    <span class="number">11000000</span></span><br><span class="line">mask |= mask &gt;&gt; <span class="number">2</span>    <span class="number">11110000</span></span><br><span class="line">mask |= mask &gt;&gt; <span class="number">4</span>    <span class="number">11111111</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findComplement</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> num;</span><br><span class="line">    mask |= mask &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    mask |= mask &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    mask |= mask &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    mask |= mask &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    mask |= mask &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (mask ^ num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="6-判断一个数的位级表示是否不会出现连续的-0-和-1"><a href="#6-判断一个数的位级表示是否不会出现连续的-0-和-1" class="headerlink" title="6.判断一个数的位级表示是否不会出现连续的 0 和 1"></a>6.判断一个数的位级表示是否不会出现连续的 0 和 1</h3><p>对于 1010 这种位级表示的数，把它向右移动 1 位得到 101，这两个数每个位都不同，因此异或得到的结果为 1111。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasAlternatingBits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> (n ^ (n &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> (a &amp; (a + <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="7-翻转一个数的比特位"><a href="#7-翻转一个数的比特位" class="headerlink" title="7.翻转一个数的比特位"></a>7.翻转一个数的比特位</h3><p><strong>method1:</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reverseBits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        ret &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        ret |= (n &amp; <span class="number">1</span>);</span><br><span class="line">        n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>method2:</strong> 如果该函数需要被调用很多次，可以将 int 拆成 4 个 byte，然后缓存 byte 对应的比特位翻转，最后再拼接起来。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, Integer&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reverseBits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        ret &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">        ret |= reverseByte((<span class="type">byte</span>) (n &amp; <span class="number">0b11111111</span>));</span><br><span class="line">        n &gt;&gt;= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">reverseByte</span><span class="params">(<span class="type">byte</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.containsKey(b)) <span class="keyword">return</span> cache.get(b);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">t</span> <span class="operator">=</span> b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        ret &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        ret |= t &amp; <span class="number">1</span>;</span><br><span class="line">        t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cache.put(b, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>计算机</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>bit</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA leetcode插件配置</title>
    <url>/posts/719102077.html</url>
    <content><![CDATA[<h3 id="IDEA-leetcode插件使用"><a href="#IDEA-leetcode插件使用" class="headerlink" title="IDEA leetcode插件使用"></a>IDEA leetcode插件使用</h3><p>进入IDEA File选项，如下图，选择plugins，搜索leetcode editor</p>
<p><img src="/../images/idea%E8%AE%BE%E7%BD%AE.png" alt="ideaSetting"></p>
<blockquote>
<p> ps: IDEA 版本2019，leetcode 6.9</p>
</blockquote>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>安装上述插件后，一直无法登陆leetcode账号，原因，官网的中文网址发生改变，但低版本插件未更新，8.0插件版本进行修复，但支持的idea版本至少20版以上，若需要用19版，插件源码需进行适当修改。</p>
<p>本人从网上下载了已经修改后的插件安装包，安装本地插件即可</p>
<h3 id="Leetcode-Editor-配置"><a href="#Leetcode-Editor-配置" class="headerlink" title="Leetcode Editor 配置"></a>Leetcode Editor 配置</h3><p>配置如下图所示：</p>
<p><img src="/../images/leetcodeEditorSett.png" alt="leetcodeEditorSett"></p>
<p>CodeFileName具体代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">$!velocityTool.camelCaseName($&#123;question.titleSlug&#125;)</span><br></pre></td></tr></table></figure></div>

<p>codeTemplate具体代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode.editor.cn;</span><br><span class="line">$&#123;question.content&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$</span>!velocityTool.camelCaseName($&#123;question.titleSlug&#125;)&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">$</span>!velocityTool.camelCaseName($&#123;question.titleSlug&#125;)().<span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    $&#123;question.code&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>







]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>云服务器配置</title>
    <url>/posts/719102029.html</url>
    <content><![CDATA[<p>云服务器配置</p>
<h3 id="mysql启动"><a href="#mysql启动" class="headerlink" title="mysql启动"></a>mysql启动</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ..</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/etc/init.d/mysql start <span class="comment">#启动mysql</span></span></span><br></pre></td></tr></table></figure></div>

<h3 id="redis位置"><a href="#redis位置" class="headerlink" title="redis位置"></a>redis位置</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ..</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /usr/local/redis/bin</span></span><br></pre></td></tr></table></figure></div>

<h3 id="redis启动"><a href="#redis启动" class="headerlink" title="redis启动"></a>redis启动</h3><p>在上述位置输入如下命令</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./redis-server ../redis.conf <span class="comment">#redis后台启动</span></span></span><br></pre></td></tr></table></figure></div>

<h3 id="nginx安装"><a href="#nginx安装" class="headerlink" title="nginx安装"></a>nginx安装</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install nginx -y</span></span><br></pre></td></tr></table></figure></div>

<h3 id="nginx位置"><a href="#nginx位置" class="headerlink" title="nginx位置"></a>nginx位置</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /etc/nginx/nginx.conf</span></span><br></pre></td></tr></table></figure></div>

<h3 id="springboot项目部署远端服务器"><a href="#springboot项目部署远端服务器" class="headerlink" title="springboot项目部署远端服务器"></a>springboot项目部署远端服务器</h3><ol>
<li><p>先使用<code>mvn clean</code>清除缓存</p>
</li>
<li><p>通过如下命令打包jar包：</p>
</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">mvn package -DskipTests=<span class="literal">true</span></span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>将本地打包好的jar包部署到远程服务器</li>
<li>启动命令，使用如下命令运行jar包：</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> jar -jar jar包名 &amp;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>注：nohup加上&amp;表示项目可以在后台永久的执行</strong>，即使关闭xshell终端也不会停止。若想停止，可直接结束该项目端口占用的进程。</p>
<p>以上命令执行后会提示“nohup:ignoring input and appending output to ‘nohup.out’”,这是正常的，不是错误提示，直接打回车即可。产生原因是<code>nohup</code>默认会把标准输出重定向到默认文件<code>nohup.out</code>中，也可以自定义该输出文件，如<code>nohup java -jar jar包 &gt;temp.txt &amp;</code></p>
</blockquote>
<ol start="5">
<li>Next博客jar位置：服务器<code>114.55.112.191</code>下&#x2F;home&#x2F;web</li>
</ol>
<h3 id="前端项目部署远端服务器"><a href="#前端项目部署远端服务器" class="headerlink" title="前端项目部署远端服务器"></a>前端项目部署远端服务器</h3><ol>
<li>vue项目使用如下命令生成目标文件：</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure></div>

<p><strong>ps :执行完上述命令则生成dist文件</strong></p>
<ol start="2">
<li><p>利用nginx做远程代理</p>
</li>
<li><p>进入Nginx配置文件<code> vim /etc/nginx/nginx.conf</code>做如下配置</p>
</li>
</ol>
<p><img src="/../images/tt.png" alt="nginx1"></p>
<ol start="4">
<li>使用命令重启nginx</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure></div>

<ol start="5">
<li>阿里云服务器安全规则配置端口，开启5370、5371两端口</li>
</ol>
<h3 id="Nginx常用命令"><a href="#Nginx常用命令" class="headerlink" title="Nginx常用命令"></a>Nginx常用命令</h3><h3 id="nginx相关命令"><a href="#nginx相关命令" class="headerlink" title="nginx相关命令"></a>nginx相关命令</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl start nginx</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl stop nginx</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl restart nginx</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl reload nginx</span></span><br><span class="line">或</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">service nginx start</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">service nginx stop</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">service nginx restart</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Nginx安装位置</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">which</span> nginx</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>nginx端口开放后，需登陆<a href="https://ecs.console.aliyun.com/securityGroupDetail/region/cn-hangzhou/groupId/sg-bp1hun17u4gm7a2r255x/detail/intranetIngress">ECS阿里云控制中心</a>安全组开放登陆端口</p>
<p>云服务器中:</p>
<ul>
<li>后台接口前端包位置：&#x2F;home&#x2F;web&#x2F;dist</li>
<li>view展示前端包位置：&#x2F;home&#x2F;web&#x2F;viewweb&#x2F;dist</li>
</ul>
<p>nginx blog前端接口层开放端口：5370</p>
<p>nginx blog前端展示层开放端口：5371</p>
</blockquote>
]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>云服务器配置</tag>
      </tags>
  </entry>
  <entry>
    <title>my first blog</title>
    <url>/posts/3594205455.html</url>
    <content><![CDATA[<h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node js"></a>安装Node js</h2><h3 id="安装nvm"><a href="#安装nvm" class="headerlink" title="安装nvm"></a>安装nvm</h3><p>下载<code>nvm-setup.exe</code>安装包，解压安装。安装目录（最好非C盘）。</p>
<p>打开nvm安装目录，找到setting文件，在文件最后添加淘宝镜像，加快node的下载</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="TXT"><figure class="iseeu highlight /txt"><table><tr><td class="code"><pre><span class="line">node_mirror: npm.taobao.org/mirrors/node/</span><br><span class="line">npm_mirror: npm.taobao.org/mirrors/npm/</span><br></pre></td></tr></table></figure></div>

<p>安装版本的会自动配置环境变量。</p>
<h3 id="安装Nodejs"><a href="#安装Nodejs" class="headerlink" title="安装Nodejs"></a>安装Nodejs</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nvm install node版本号</span></span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nvm install 16.14.1</span></span><br></pre></td></tr></table></figure></div>

<h3 id="使用指定node版本"><a href="#使用指定node版本" class="headerlink" title="使用指定node版本"></a>使用指定node版本</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nvm use node版本</span></span><br><span class="line">例如：</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nvm use 16.14.1</span></span><br></pre></td></tr></table></figure></div>

<p>若出现乱码<code>exit status 1: ��û���㹻��Ȩ��ִ�д˲�����</code>，解决方案：</p>
<ul>
<li>使用<strong>管理员模式</strong>运行终端 (win10 系统可以右键 win 图标, 选择 “Windows PowerShell(管理员)”)</li>
</ul>
<h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><ul>
<li>卸载node</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nvm uninstall node版本号</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>显示nvm管理的所有node</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nvm <span class="built_in">ls</span></span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>显示当前所使用node版本</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nvm current</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>显示nvm版本</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nvm version</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>显示网上所有可以使用的node版本</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nvm list available</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>如果mac要改变默认的node版本，使用<code>nvm use node版本</code>命名只是暂时改变node版本，等下次启动的时候还是原来默认的那个版本，所以需要执行如下命令来对node版本进行选择<br><code>nvm alias default node版本</code></p>
</blockquote>
<h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p><a href="https://hexo.io/zh-cn/docs/setup">hexo安装文档</a></p>
<p><a href="http://theme-next.iissnan.com/">Next主题配置文档</a></p>
<p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install -g hexo-cli</span></span><br></pre></td></tr></table></figure></div>

<h3 id="进阶安装和使用"><a href="#进阶安装和使用" class="headerlink" title="进阶安装和使用"></a>进阶安装和使用</h3><p>对于熟悉 npm 的进阶用户，可以仅局部安装 <code>hexo</code> 包。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install hexo</span></span><br></pre></td></tr></table></figure></div>

<p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo init &lt;folder&gt;$ <span class="built_in">cd</span> &lt;folder&gt;$ npm install</span></span><br></pre></td></tr></table></figure></div>

<p>新建完成后，指定文件夹的目录如下：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line"><span class="string">|   ├── _drafts</span></span><br><span class="line"><span class="string">|   └── _posts</span></span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>

<p>本地预览</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo s</span></span><br></pre></td></tr></table></figure></div>

<p>若本地预览出现，需补充安装</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm i hexo-renderer-swig</span></span><br></pre></td></tr></table></figure></div>

<h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><h3 id="添加「标签」页面"><a href="#添加「标签」页面" class="headerlink" title="添加「标签」页面"></a>添加「标签」页面</h3><p>新建「标签」页面，并在菜单中显示「标签」链接。「标签」页面将展示站点的所有标签，若你的所有文章都未包含标签，此页面将是空的。 底下代码是一篇包含标签的文章的例子：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">标签测试文章</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Testing</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Another</span> <span class="string">Tag</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></div>

<h4 id="新建页面"><a href="#新建页面" class="headerlink" title="新建页面"></a>新建页面</h4><p>在终端窗口下，定位到 Hexo 站点目录下。使用 <code>hexo new page</code> 新建一个页面，命名为 <code>tags</code> ：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> your-hexo-site</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo new page tags</span></span><br></pre></td></tr></table></figure></div>

<h4 id="设置页面类型"><a href="#设置页面类型" class="headerlink" title="设置页面类型"></a>设置页面类型</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="TXT"><figure class="iseeu highlight /txt"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></div>

<h4 id="修改菜单"><a href="#修改菜单" class="headerlink" title="修改菜单"></a>修改菜单</h4><p>在菜单中添加链接。编辑 <strong>主题配置文件</strong> ， 添加 <code>tags</code> 到 <code>menu</code> 中，如下:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="DTS"><figure class="iseeu highlight /dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">menu:</span></span><br><span class="line"><span class="symbol">  home:</span> /</span><br><span class="line"><span class="symbol">  archives:</span> /archives</span><br><span class="line"><span class="symbol">  tags:</span> /tags</span><br></pre></td></tr></table></figure></div>

<p>接下来可以执行下列命令来创建一篇新文章或者新的页面。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="GAUSS"><figure class="iseeu highlight /gauss"><table><tr><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> [layout] &lt;<span class="built_in">title</span>&gt;</span><br></pre></td></tr></table></figure></div>

<p>您可以在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局</p>
<p>如创建一篇新文章my first blog</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo new my first blog</span></span><br></pre></td></tr></table></figure></div>

<p>创建的文章在目录&#x2F;source&#x2F;_post下，在文章开头增加配置指定该文章所属分类和标签：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="TXT"><figure class="iseeu highlight /txt"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: my first blog</span><br><span class="line">date: 2023-07-02 23:17:12</span><br><span class="line">tags: </span><br><span class="line">- NexT</span><br><span class="line">- blog</span><br><span class="line">categories: 博客</span><br><span class="line">---</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>NexT</tag>
        <tag>blog</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
